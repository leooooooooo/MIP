//
//  NewPDFPaintController.m
//  MOA
//
//  Created by  on 11-12-14.
//  Copyright (c) 2011年 __MyCompanyName__. All rights reserved.
//

#import "PDFToolViewController.h"

#import "PaintUtility.h"
#import "TempNotePageManagement.h"

#import "CustomAlertView.h"
#import "CustomNewAlertView.h"
#import "UIColor+CustomExtensions.h"

#import <QuartzCore/QuartzCore.h>
#import "UILabel+CustomExtensions.h"


NSString *const kPDFInfoPermission = @"PDFInfoPermission";//PDF信息查看权限
NSString *const kPDFCommitPermission = @"PDFCommitPermission";//PDF提交权限
NSString *const kPDFSignPermission = @"PDFSignPermission";//PDF签批权限
NSString *const kPDFAccessoryPermission = @"PDFAccessoryPermission";//PDF附件权限
NSString *const kPDFHelpPermission = @"PDFHelpPermission";//PDF帮助权限
NSString *const kPDFCheckPermission = @"PDFCheckPermission";//PDF查看权限

@interface PDFToolViewController () {
    
    NSMutableDictionary             *permissionDictionary;//用于存放PDF工具栏的权限字典
}

@end


@implementation PDFToolViewController
@synthesize document;

@synthesize delegate = _delegate;
@synthesize displayDelegate = _displayDelegate;


- (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil
{
    self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil];
    if (self) {
        // Custom initialization
    }
    return self;
}

- (id)initWithDocument:(PDFDocument *)doc
{
	if ((self = [super initWithNibName:nil bundle:nil])) {
        
        if (!permissionDictionary) {
            
            permissionDictionary = [[NSMutableDictionary alloc] initWithCapacity:3];
            //默认所有 可配置权限都为yes
            [permissionDictionary setObject:[NSNumber numberWithInteger:ON] forKey:kPDFInfoPermission];
            [permissionDictionary setObject:[NSNumber numberWithInteger:ON] forKey:kPDFCommitPermission];
            [permissionDictionary setObject:[NSNumber numberWithInteger:ON] forKey:kPDFSignPermission];
            [permissionDictionary setObject:[NSNumber numberWithInteger:OFF] forKey:kPDFAccessoryPermission];
            [permissionDictionary setObject:[NSNumber numberWithInteger:ON] forKey:kPDFHelpPermission];
            [permissionDictionary setObject:[NSNumber numberWithInteger:OFF] forKey:kPDFCheckPermission];
        }
        
        self.document = doc;
	}
	
	return self;
}

- (void)loadPDFDocument:(PDFDocument *)doc
{
    self.document = doc;
    
    NSURL *pdfURL = nil;
    
    if (self.document.url) {
        
        pdfURL = [NSURL fileURLWithPath:self.document.url isDirectory:NO];
        
        [pdfScrollView reloadPDFView:pdfURL];
        
        [pdfScrollView setZoomScale:1.25 animated:NO];
        pdfScrollView.contentOffset = CGPointMake(0, 0);
    }
    
    titleLabel.text = document.title;
}

- (void)loadView
{
    UIView *tempView = [[UIView alloc] initWithFrame:CGRectMake(0, 20, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height-20)];
    self.view = tempView;
    [tempView release];
}

// Implement viewDidLoad to do additional setup after loading the view, typically from a nib.
- (void)viewDidLoad {
    
    [super viewDidLoad];
    
    self.view.backgroundColor = [UIColor blackColor];
    
    UIView *bgView = [[UIView alloc] initWithFrame:CGRectMake(0, 30, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height-30)];
    bgView.backgroundColor = [UIColor whiteColor];
    [self.view addSubview:bgView];
    [bgView release];
    
    UIImageView *navBarImg = [[UIImageView alloc] initWithFrame:CGRectMake(0, 20, self.view.frame.size.width, 54)];
    navBarImg.image = [UIImage imageNamed:[kPDFReaderStyle1Bundle stringByAppendingPathComponent:@"titleBar_bg.png"]];
    [self.view addSubview:navBarImg];
    [navBarImg release];
    
    UIButton *backBtn = [UIButton buttonWithType:UIButtonTypeCustom];
    backBtn.frame = CGRectMake(5, 25, 60, 40);
    [backBtn setBackgroundImage:[UIImage imageNamed:[kPDFReaderStyle1Bundle stringByAppendingPathComponent:@"t_back.png"]] forState:UIControlStateNormal];
    [backBtn addTarget:self action:@selector(back) forControlEvents:UIControlEventTouchUpInside];
    [self.view addSubview:backBtn];
    
	isNeedEncrypt = NO;
	
//    UIInterfaceOrientation orientation = [UIApplication sharedApplication].statusBarOrientation;
    
//	CGRect rect = CGRectMake(kDrawingScrollViewMargin, kDrawingScrollViewTopMargin, kDrawingScrollViewWidthPortait, kDrawingScrollViewHeightPortait);
//    CGRect tiledRect = CGRectMake(0,0,kDrawingScrollViewWidthPortait,kDrawingScrollViewHeightPortait);
    CGRect rect = CGRectMake(0, 54+20, 320, [UIScreen mainScreen].bounds.size.height-54-20);
    CGRect tiledRect = CGRectMake(0,0,320,[UIScreen mainScreen].bounds.size.height-20-54);

    NSURL *pdfURL = nil;
    
    NSLog(@"----------%@",self.document.url);
    
    if (self.document.url) {
        
        pdfURL = [NSURL fileURLWithPath:self.document.url isDirectory:NO];
    }
    else
    {
        return;
    }
    
    pdfScrollView = [[CommonPDFScrollView alloc] initWithFrame:rect tiledFrame:tiledRect pdfURL:pdfURL needDrawingView:NO delegate:self];
    [pdfScrollView setScrollViewDelegate:self];
    pdfScrollView.zoomScale = 1.25;
    [self.view addSubview:pdfScrollView];
    
    helpImageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 320, [UIScreen mainScreen].bounds.size.height)];
    helpImageView.userInteractionEnabled = YES;
    helpImageView.alpha = 0.0;
    
    UITapGestureRecognizer *singleTapOne = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(hiddenHelpImageView:)];
    
	singleTapOne.numberOfTouchesRequired = 1;
    singleTapOne.numberOfTapsRequired = 1;
    
	[helpImageView addGestureRecognizer:singleTapOne];
    [singleTapOne release];
/*
    UIImage *backImage = [PaintUtility imageNamedFromContentFile:[kPDFReaderStyle1Bundle stringByAppendingPathComponent:@"bg_pdf.png"]];
    
    backgroundView = [[UIImageView alloc] initWithImage:[backImage resizableImageWithCapInsets:UIEdgeInsetsMake(20, 20, 20, 20)]];
    
    backgroundView.frame = CGRectMake(0, 0, 1024, 748);
    
    [self.view addSubview:backgroundView];
    
    [self.view sendSubviewToBack:backgroundView];

    browseToolbar = [[PDFBrowseToolbar alloc] initWithFrame:CGRectMake(1024-50, 30, 50, 570)];
    
    browseToolbar.delegate = self;
    
    [self.view addSubview:browseToolbar];

    funcToolbar = [[PDFFuncToolbar alloc] initWithFrame:CGRectMake(0, 0, 60, 748)];
    
    funcToolbar.delegate = self;
    
    [self.view addSubview:funcToolbar];
    
    signToolbar = [[PDFSignToolbar alloc] initWithFrame:CGRectMake(1024, 30, 110, 710)];
    signToolbar.hidden = YES;
    
    signToolbar.delegate = self;
    
    [self.view addSubview:signToolbar];
    
    [self newPage];
    */
    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
    
    //设置画笔颜色

    [[pdfScrollView getDrawingView] setBrushColorWithRed:0 green:0 blue:0];
   // add by lixiangai
    CGFloat red;
    CGFloat green;
    CGFloat blue;
    CGFloat alpha;
    NSString *str = [userDefaults objectForKey:@"paintbrushColor"];
    NSArray *arr = [str componentsSeparatedByString:@","];
    
    if (arr)
    {
        red = [[arr objectAtIndex:0] floatValue];
        green =[[arr objectAtIndex:1] floatValue];
        blue = [[arr objectAtIndex:2] floatValue];
        alpha = [[arr objectAtIndex:3] floatValue];
        [[pdfScrollView getDrawingView] setBrushColorWithRed:red  green:green blue:blue];
        [signToolbar setcurrentColorButton:[[arr objectAtIndex:4] integerValue]];
    }
 
   //end

    NSString *size = [userDefaults stringForKey:@"paintbrushSize"];
    
    if (size == nil) {
        
        size = @"2";
    }
    //设置画笔粗细
    [[pdfScrollView getDrawingView] setBruchScaleLevel:[size integerValue]];
    signToolbar.size = [size integerValue];
    
    UIView *labView = [[UIView alloc] initWithFrame:CGRectMake(70, 20, 250, 50)];
    labView.backgroundColor = [UIColor clearColor];
    labView.clipsToBounds = YES;
    [self.view addSubview:labView];
    [labView release];
    
    //标题Label
    titleLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 250, 50)];
    titleLabel.font = [UIFont boldSystemFontOfSize:20];
    titleLabel.textColor = [UIColor whiteColor];
    titleLabel.backgroundColor = [UIColor clearColor];
    
	titleLabel.textAlignment = UITextAlignmentCenter;
    
    titleLabel.text = document.title;
    
    titleLabel.alpha = 1.0;
    
    [labView addSubview:titleLabel];
    
    if (![titleLabel textIsLongerThanWidth])
    {
        CGRect rect = titleLabel.frame;
        rect.size.width = 180;
        titleLabel.frame = rect;
    }
    
    //titleLabel初始化完毕后,调用代理方法
    if ([_displayDelegate respondsToSelector:@selector(PDFViewInitializeTitleLabel:)]) {
        
        [_displayDelegate PDFViewInitializeTitleLabel:titleLabel];
    }
    
    
//    pageToolBar = [[UIToolbar alloc] initWithFrame:CGRectMake(0, 1024 - 44, 768, 44)];
//    pageHighlightedLabel = [[UILabel alloc] initWithFrame:CGRectMake(768/2 -23, 1024 - 44 - 30, 46, 20)];
//    
//    pageHighlightedLabel.textAlignment = UITextAlignmentCenter;
//    pageHighlightedLabel.textColor = [UIColor whiteColor];
//    pageHighlightedLabel.font = [UIFont boldSystemFontOfSize:14];
//    [pageHighlightedLabel setBackgroundColor:[UIColor colorWithRed:76.0/255 green:76.0/255 blue:76.0/255 alpha:1.0]];
//    [pageHighlightedLabel setAlpha:0.8];
//
//    [pageToolBar setBarStyle:UIBarStyleBlackTranslucent];
//    [pageToolBar setBackgroundColor:[UIColor clearColor]];
//    pageToolBar.opaque = NO;
//    [pageToolBar setAlpha:0.8];
//
//    [self.view addSubview:pageToolBar];
//    [self.view addSubview:pageHighlightedLabel];
    
//    [self willRotateToInterfaceOrientation:orientation duration:0.0];
    
    if (!pdfScrollView.canOpen) {
        UIAlertView *alertView = [[UIAlertView alloc]
                                  initWithTitle:@"错误"
                                  message:@"PDF文件已损坏"
                                  delegate:self
                                  cancelButtonTitle:@"好"
                                  otherButtonTitles:
                                  nil];
        [alertView show];
        [alertView release];
    }
    
    [self updateToolbar];
    
    //按住移动视图
    touchView = [[UIView alloc] initWithFrame:CGRectMake(-69, 210, 69, 256)];
    touchView.backgroundColor = [UIColor clearColor];
    [self.view addSubview:touchView];
    
    touchImageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 69, 121)];
    touchImageView.image = [UIImage imageNamed:[kPDFReaderStyle1Bundle stringByAppendingPathComponent:@"touchImage_normal.png"]];
    [touchView addSubview:touchImageView];
    
    UIButton *touchButton = [UIButton buttonWithType:UIButtonTypeCustom];
    touchButton.frame = CGRectMake(0, 121, 69, 135);
    
    [touchButton setBackgroundImage:[UIImage imageNamed:[kPDFReaderStyle1Bundle stringByAppendingPathComponent:@"touchButton_normal.png"]] forState:UIControlStateNormal];
    [touchButton setBackgroundImage:[UIImage imageNamed:[kPDFReaderStyle1Bundle stringByAppendingPathComponent:@"touchButton_light.png"]] forState:UIControlStateHighlighted];
    [touchButton setBackgroundImage:[UIImage imageNamed:[kPDFReaderStyle1Bundle stringByAppendingPathComponent:@"touchButton_light.png"]] forState:UIControlStateSelected];
    
    [touchButton addTarget:self action:@selector(touchButtonTouchDown:) forControlEvents:UIControlEventTouchDown];
    [touchButton addTarget:self action:@selector(touchButtonTouchDown:) forControlEvents:UIControlEventTouchDragEnter];
    [touchButton addTarget:self action:@selector(touchButtonTouchUpInside:) forControlEvents:UIControlEventTouchUpInside];
    [touchButton addTarget:self action:@selector(touchButtonTouchUpInside:) forControlEvents:UIControlEventTouchDragExit];
    
    [touchView addSubview:touchButton];
    
    BottomBarView *bottomBarView = [[BottomBarView alloc] initWithFrame:CGRectMake(0, [UIScreen mainScreen].bounds.size.height - 55, 320, 50)];
    bottomBarView.barDelegate = self;
    
    NSNumber *permission = [permissionDictionary objectForKey:kPDFCheckPermission];
    [bottomBarView loadBottomItemDataHasAccessory:[permission boolValue]];
    
    [self.view addSubview:bottomBarView];
    [bottomBarView release];
}

- (void)back
{
    if ([_delegate respondsToSelector:@selector(tappedInPDFToolbar:backButton:)]) {
        
        [_delegate tappedInPDFToolbar:nil backButton:nil];
    }
    
    [self dismissPDFToolViewController];
}

- (void)touchButtonTouchDown:(UIButton *)button
{
    if (pdfScrollView && [pdfScrollView getIsNeedDrawingView])
    {
        [pdfScrollView removeDrawingView];
    }
    
    touchImageView.image = [UIImage imageNamed:[kPDFReaderStyle1Bundle stringByAppendingPathComponent:@"touchImage_light.png"]];
}

- (void)touchButtonTouchUpInside:(UIButton *)button
{
    if (pdfScrollView && ![pdfScrollView getIsNeedDrawingView])
    {
        [pdfScrollView restoreDrawingView];
        
        [[pdfScrollView getDrawingView] setChangedScaleFactor:1.0];
    }
    
    touchImageView.image = [UIImage imageNamed:[kPDFReaderStyle1Bundle stringByAppendingPathComponent:@"touchImage_normal.png"]];
}

- (void)viewDidAppear:(BOOL)animated {
    
    [super viewDidAppear:animated];
    
    CGSize labelSize = [titleLabel.text sizeWithFont:titleLabel.font];
    
    if (titleLabel.frame.size.width < labelSize.width)
    {
        [titleLabel widthFitLabText];
        [titleLabel showMarqueeStyle];
    }
    
    dispatch_async(dispatch_get_main_queue(), ^{
        
        [TempNotePageManagement deleteAllTempPage];
    });
}

//设置PDF工具栏的功能权限
- (void)setToolbarPermission:(PDFToolPermission)permission forKey:(NSString *)key {
    
    [permissionDictionary setObject:[NSNumber numberWithInteger:permission] forKey:key];
    [self updateToolbar];
}

//根据PDF工具栏的权限更新工具栏的UI
- (void)updateToolbar {
    
    NSNumber *permission = [permissionDictionary objectForKey:kPDFInfoPermission];
    
    funcToolbar.infoButton.hidden = ![permission boolValue];
    
    permission = [permissionDictionary objectForKey:kPDFCommitPermission];
    
    funcToolbar.sendButton.hidden = ![permission boolValue];
    
    permission = [permissionDictionary objectForKey:kPDFSignPermission];
    
    browseToolbar.startSignButton.hidden = ![permission boolValue];
    
    permission = [permissionDictionary objectForKey:kPDFAccessoryPermission];
    
    funcToolbar.accessoryButton.hidden = ![permission boolValue];
    
    permission = [permissionDictionary objectForKey:kPDFHelpPermission];
    
    funcToolbar.helpButton.hidden = ![permission boolValue];
    
    permission = [permissionDictionary objectForKey:kPDFCheckPermission];
    
    funcToolbar.checkButton.hidden = ![permission boolValue];
}

- (void)refreshPageToolBar//刷新页码工具栏
{
    if (UIInterfaceOrientationIsLandscape(self.interfaceOrientation)) {//横屏
        CGRect rect= CGRectMake(0, 748 - 44, 1024, 44);
        pageToolBar.frame = rect;
        pageHighlightedLabel.frame = CGRectMake(1024/2 -23, 768 - 44 - 30, 46, 20);
        [pageHighlightedLabel setText:[NSString stringWithFormat:@"%d/%zd",pdfScrollView.currentIdx,pdfScrollView.pages]];
        int maxCount = 38+1;
        int totalCount = pdfScrollView.pages;
        int currentPageIndex = pdfScrollView.currentIdx;
        int pageScale = totalCount/maxCount;
        int arrayCount = 0;
        arrayCount = (totalCount)/(pageScale+1);

        NSMutableArray *buttonsArray = [[NSMutableArray alloc] initWithCapacity:arrayCount+3];
        UIBarButtonItem *flexLeft = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFlexibleSpace target:self action:nil];
        [flexLeft setTag:0];
        [buttonsArray insertObject:flexLeft atIndex:0];
        [flexLeft release];
        int j = 1;
        for (int i = 1; i<=totalCount ; j++) {
            UIBarButtonItem *buttonItem = [[UIBarButtonItem alloc] initWithImage:[PaintUtility imageNamedFromContentFile:[kPDFReaderStyle1Bundle stringByAppendingPathComponent:@"bg_thumb1.png"]] style:UIBarButtonItemStylePlain target:self action:@selector(buttonItemPressed:)];
            [buttonItem setTag:(i+pageScale+1)>totalCount?totalCount:i];
            if (i<=currentPageIndex && currentPageIndex<=i+pageScale) {
                [buttonItem setImage:[PaintUtility imageNamedFromContentFile:[kPDFReaderStyle1Bundle stringByAppendingPathComponent:@"bg_thumb2.png"]]];
            }
            [buttonsArray insertObject:buttonItem atIndex:j];
            [buttonItem release];
            i+=pageScale+1;
        }
        UIBarButtonItem *flexRight = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFlexibleSpace target:self action:nil];
        [buttonsArray insertObject:flexRight atIndex:j];
        [flexRight release];
        [pageToolBar setItems:buttonsArray animated:YES];
        [buttonsArray release];
    }
    
    if (pdfScrollView.currentIdx > 1) {
        browseToolbar.previousButton.userInteractionEnabled = YES;
        browseToolbar.previousButton.hidden = NO;
    }
    else {
        browseToolbar.previousButton.userInteractionEnabled = NO;
        browseToolbar.previousButton.hidden = YES;
    }
    if(pdfScrollView.currentIdx < pdfScrollView.pages ) {
        browseToolbar.nextButton.userInteractionEnabled = YES;
        browseToolbar.nextButton.hidden = NO;
    }
    else {
        browseToolbar.nextButton.userInteractionEnabled = NO;
        browseToolbar.nextButton.hidden = YES;
    }
}

//书页按钮被按中触发的事件
- (void)buttonItemPressed:(id)sender
{
    //翻页
    [pdfScrollView turnToPage:[sender tag]];
    
    [self refreshPageToolBar ];
}

- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation {
    
    return UIInterfaceOrientationIsLandscape(interfaceOrientation);
}
//横竖屏转换的时候触发
- (void)willRotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration
{
    
    [pdfScrollView changeOrientation:toInterfaceOrientation];
    
    [self refreshPageToolBar];
    
    if (UIInterfaceOrientationIsLandscape(toInterfaceOrientation)) {
        
        
        //标题
        [titleLabel setFrame:CGRectMake(260+50, 0, 500, 40)];
        
        backgroundView.frame = CGRectMake(0, 0, 1024, 748);
        helpImageView.frame = CGRectMake(0, 0, 1024, 748);
        
        funcToolbar.frame = CGRectMake(0, 0, 60, 748);
        
        if (signToolbar.isHidden) {
            
            signToolbar.frame = CGRectMake(1024, 20, 110, 710);
            browseToolbar.frame = CGRectMake(1024-50, 20, 50, 570);
        }
        else {
            
            signToolbar.frame = CGRectMake(1024-110, 20, 110, 710);
            browseToolbar.frame = CGRectMake(1024, 20, 50, 570);
        }
        
        if ([[UIDevice currentDevice].systemVersion doubleValue] >=7.0)
        {
            [titleLabel setFrame:CGRectMake(260+50, 20, 500, 40)];
            
            backgroundView.frame = CGRectMake(0, 20, 1024, 748);
            helpImageView.frame = CGRectMake(0, 20, 1024, 748);
            
            funcToolbar.frame = CGRectMake(0, 20, 60, 748);
            
            if (signToolbar.isHidden) {
                
                signToolbar.frame = CGRectMake(1024, 40, 110, 710);
                browseToolbar.frame = CGRectMake(1024-50, 40, 50, 570);
            }
            else {
                
                signToolbar.frame = CGRectMake(1024-110, 40, 110, 710);
                browseToolbar.frame = CGRectMake(1024, 40, 50, 570);
            }
            
        }
    }
}

- (void)didRotateFromInterfaceOrientation:(UIInterfaceOrientation)fromInterfaceOrientation
{
    [pdfScrollView didChangeOrientation:fromInterfaceOrientation];
}

- (void)didReceiveMemoryWarning {
    // Releases the view if it doesn't have a superview.
    [super didReceiveMemoryWarning];
    
    // Release any cached data, images, etc. that aren't in use.
}


- (void)viewDidUnload {
    [super viewDidUnload];
    // Release any retained subviews of the main view.
    // e.g. self.myOutlet = nil;
}

- (void)hiddenHelpImageView:(UITapGestureRecognizer *)recognizer {
    
    [UIView animateWithDuration:0.5 animations:^{
        
        helpImageView.alpha = 0.0;
        
    } completion:^(BOOL finished) {
        
        [helpImageView removeFromSuperview];
    }];
}

- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex
{
    switch (alertView.tag) {
        case kAlertViewFlipConfirm:
        {
            if (buttonIndex == 1) {
                [pdfScrollView flipBackgroundImageView];
            }
            break;
        }
            
        case kAlertViewSignBack:
        {
            if (1 == buttonIndex)
            {
                [self savePDF];
            }
            
            [self dismissModalViewControllerAnimated:YES];
            
            break;
        }
            
        default:
            break;
    }
}

- (void)dismissPDFToolViewController {
    
    if ([[pdfScrollView getDrawingView] getIsEdit])
    {
        UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@"提示"
                                                            message:@"是否对签批内容进行保存？"
                                                           delegate:self
                                                  cancelButtonTitle:@"否"
                                                  otherButtonTitles:@"是", nil];
        alertView.tag = kAlertViewSignBack;
        [alertView show];
        [alertView release];
    }
    else
    {
        [self dismissModalViewControllerAnimated:YES];
    }
}


- (void)clearDrawingBoard {
    
    [[pdfScrollView getDrawingView] erase];
}


- (void)startSign {
    
    if (!signToolbar.isHidden) {
        
        return;
    }
    
    CGRect rect0 = browseToolbar.frame;
    
    rect0.origin.x = rect0.origin.x + rect0.size.width;
    
    signToolbar.hidden = NO;
    
    //禁止功能工具栏按钮的可用状态
    [funcToolbar setFuncButtonEnable:NO];
    
    CGRect rect1 = signToolbar.frame;
    
    rect1.origin.x = rect1.origin.x - rect1.size.width;
    
    [UIView animateWithDuration:0.5 animations:^{
        
        browseToolbar.frame = rect0;
        signToolbar.frame = rect1;
        
    } completion:^(BOOL finished) {
        
        browseToolbar.hidden = YES;
    }];
    
    
    
    if (pdfScrollView.currentPdfScaleWidth <= pdfScrollView.initPdfScaleWidth) {
        pdfScrollView.isFirstSign = NO;
        
        [pdfScrollView setZoomScale:2.0 animated:YES];
        [pdfScrollView setContentOffset:CGPointMake(0, 0) animated:YES];
    }
    
    [UIView animateWithDuration:0.5 animations:^{
        
        [pageToolBar setAlpha:0.0];
        [pageHighlightedLabel setAlpha:0.0];
        [titleLabel setAlpha:0.0];
    }];
    
    if (pdfScrollView) {
        [pdfScrollView restoreDrawingView];
        
        [[pdfScrollView getDrawingView] setChangedScaleFactor:1.0];
    }
    
    //隐藏功能栏，显示按住移动视图
    CGRect funcBarRect = funcToolbar.frame;
    CGRect touchViewRect = touchView.frame;
    
    funcBarRect.origin.x = - funcToolbar.frame.size.width;
    touchViewRect.origin.x = 0;
    
    [UIView animateWithDuration:0.5 animations:^{
        
        funcToolbar.frame = funcBarRect;
        touchView.frame = touchViewRect;
        
    }];
}

- (void)endSign {
    
    if (!browseToolbar.isHidden)
        return;
    
    browseToolbar.hidden = NO;
    
    //恢复功能工具栏按钮的可用状态
    [funcToolbar setFuncButtonEnable:YES];
    
    CGRect rect0 = browseToolbar.frame;
    
    rect0.origin.x = rect0.origin.x - rect0.size.width;
    
    CGRect rect1 = signToolbar.frame;
    
    rect1.origin.x = rect1.origin.x + rect1.size.width;
    
    [UIView animateWithDuration:0.5 animations:^{
        
        browseToolbar.frame = rect0;
        signToolbar.frame = rect1;
        
    } completion:^(BOOL finished) {
        
        signToolbar.hidden = YES;
    }];
    
    if (pdfScrollView && [pdfScrollView getIsNeedDrawingView]) {//签批状态，切换到浏览
        
        [pdfScrollView setZoomScale:1.0 animated:YES];
        
        [pdfScrollView removeDrawingView];
    }
    
    //显示功能栏，隐藏按住移动视图
    CGRect funcBarRect = funcToolbar.frame;
    CGRect touchViewRect = touchView.frame;
    
    funcBarRect.origin.x = 0;
    touchViewRect.origin.x = - touchView.frame.size.width;
    
    [UIView animateWithDuration:0.5 animations:^{
        
        funcToolbar.frame = funcBarRect;
        touchView.frame = touchViewRect;
        
    }];
}

- (void)savePDF
{
    //add by lch end
	pdfScrollView.exclusiveTouch = NO;
	pdfScrollView.userInteractionEnabled = NO;
    
    NSString *newFilePath = self.document.url;
    
    const char *filename = [newFilePath UTF8String]; 
    CGRect pageRect = [[UIScreen mainScreen] applicationFrame];
    // This code block sets up our PDF Context so that we can draw to it 
    CGContextRef pdfContext; 
    CFStringRef path; 
    CFURLRef url; 
    CFMutableDictionaryRef myDictionary = NULL; 
    // Create a CFString from the filename we provide to this method when we call it 
    path = CFStringCreateWithCString (NULL, filename, 
                                      kCFStringEncodingUTF8); 
    // Create a CFURL using the CFString we just defined 
    url = CFURLCreateWithFileSystemPath (NULL, path, 
                                         kCFURLPOSIXPathStyle, 0); 
    CFRelease (path); 
    // This dictionary contains extra options mostly for ‘signing’ the PDF 
    myDictionary = CFDictionaryCreateMutable(NULL, 0, 
                                             &kCFTypeDictionaryKeyCallBacks, 
                                             &kCFTypeDictionaryValueCallBacks); 
    CFDictionarySetValue(myDictionary, kCGPDFContextTitle, CFSTR("My PDF File")); 
    CFDictionarySetValue(myDictionary, kCGPDFContextCreator, CFSTR("My Name"));

	if (isNeedEncrypt) {
		CFDictionarySetValue(myDictionary, kCGPDFContextOwnerPassword, CFSTR("Comprise"));
		CFDictionarySetValue(myDictionary, kCGPDFContextUserPassword, CFSTR("Comprise"));
	}
	
    // Create our PDF Context with the CFURL, the CGRect we provide, and the above defined dictionary 
    pdfContext = CGPDFContextCreateWithURL (url, &pageRect, myDictionary); 
    // Cleanup our mess 
    CFRelease(myDictionary); 
    CFRelease(url); 
    

	CGRect thisRect;
	for(int i = 0; i < pdfScrollView.pages; i ++)
	{
		CGPDFPageRef page = CGPDFDocumentGetPage(pdfScrollView.pdf, i + 1);
		thisRect = CGPDFPageGetBoxRect(page, kCGPDFMediaBox);
		CGPDFPageRetain(page);
		float thisRectWidth = thisRect.size.width;
        float thisRectHeight = thisRect.size.height;
		//CGContextBeginPage (pdfContext, &thisRect);
        
        NSInteger flipAngle = kDrawingScrollViewFlip0;
        if ([pdfScrollView.isFlipPages objectForKey:[NSNumber numberWithInt:i+1]] && [[pdfScrollView.isFlipPages objectForKey:[NSNumber numberWithInt:i+1]] intValue] >= kDrawingScrollViewFlip0) {//确实被翻转过了
            flipAngle = [[pdfScrollView.isFlipPages objectForKey:[NSNumber numberWithInt:i+1]] intValue];
        }
        switch (flipAngle) {
            case kDrawingScrollViewFlip0://正常角度
                CGContextBeginPage (pdfContext, &thisRect);
                break;
            case kDrawingScrollViewFlip90://翻转90度
                thisRect = CGRectMake(thisRect.origin.x, thisRect.origin.y, thisRectHeight, thisRectWidth);
                CGContextBeginPage (pdfContext, &thisRect);
                CGContextTranslateCTM (pdfContext, 0,thisRect.size.height);
                CGContextRotateCTM(pdfContext, (-1)*M_PI/2.0);

                break;
            case kDrawingScrollViewFlip180://翻转180度
                CGContextBeginPage (pdfContext, &thisRect);
                CGContextTranslateCTM (pdfContext, thisRect.size.width,thisRect.size.height);
                CGContextRotateCTM (pdfContext, M_PI);
                break;
            case kDrawingScrollViewFlip270://翻转270度
                thisRect = CGRectMake(thisRect.origin.x, thisRect.origin.y, thisRectHeight, thisRectWidth);
                CGContextBeginPage (pdfContext, &thisRect);
                CGContextTranslateCTM (pdfContext, thisRect.size.width,0);
                CGContextRotateCTM(pdfContext, M_PI/2.0);
                break;
            default:
                break;
        }
		//draw the orginal pdf page
		CGContextDrawPDFPage(pdfContext, page);
		//if has signed, draw the drawing page
		//current page
        switch (flipAngle) {
            case kDrawingScrollViewFlip0://正常角度
                break;
            case kDrawingScrollViewFlip90://翻转90度
                CGContextRotateCTM(pdfContext, M_PI/2.0);
                CGContextTranslateCTM (pdfContext, 0,(-1)*thisRect.size.height);
                break;
            case kDrawingScrollViewFlip180://翻转180度
                CGContextTranslateCTM (pdfContext, thisRectWidth,thisRectHeight);
                CGContextRotateCTM (pdfContext, M_PI);
                break;
            case kDrawingScrollViewFlip270://翻转270度
                CGContextRotateCTM(pdfContext, (-1)*M_PI/2.0);
                CGContextTranslateCTM (pdfContext, (-1)*thisRect.size.width,0);
                break;
            default:
                break;
        }
        
        
        BOOL isNeedFreeBuffer2 = NO;
		if((i + 1) == pdfScrollView.currentIdx && [[pdfScrollView getDrawingView] getIsEdit])
		{
			UIImage *viewImage = [[pdfScrollView getDrawingView] glToUIImage];
            isNeedFreeBuffer2 = YES;
			CGImageRef pageImage = [viewImage CGImage];
			CGContextDrawImage(pdfContext, CGRectMake(0, 0, thisRect.size.width, thisRect.size.height), pageImage);
		}
		else {
			UIImage *viewImage = [TempNotePageManagement getNotePage:i+1];
			if(viewImage){
				CGImageRef pageImage = [viewImage CGImage]; 
				CGContextDrawImage(pdfContext, CGRectMake(0, 0, thisRect.size.width, thisRect.size.height), pageImage);
			}
		}
		CGContextEndPage (pdfContext);
		
		CGPDFPageRelease(page);
        if (isNeedFreeBuffer2) {
            [[pdfScrollView getDrawingView] freeBuffer2];
        }
	}
	
    // We are done with our context now, so we release it 
    CGContextRelease (pdfContext);
	
	pdfScrollView.exclusiveTouch = YES;
	pdfScrollView.userInteractionEnabled = YES;
    
}


#pragma mark -
#pragma mark PDFScrollDelegate delegate
//实现PDFScrollView的代理
-(void)newPage
{
    //处理翻页的ToolBar
    [pageHighlightedLabel setText:[NSString stringWithFormat:@"%d/%zd",pdfScrollView.currentIdx,pdfScrollView.pages]];
    NSArray *buttonArray = pageToolBar.items;
    if (buttonArray ) {
        for (int i = 1; i <= buttonArray.count - 2 ; i++ ) {
            UIBarButtonItem *item = [buttonArray objectAtIndex:i];
            if ([[buttonArray objectAtIndex:i-1] tag]<pdfScrollView.currentIdx && [[buttonArray objectAtIndex:i] tag]>=pdfScrollView.currentIdx) {
                [item setImage:[PaintUtility imageNamedFromContentFile:[kPDFReaderStyle1Bundle stringByAppendingPathComponent:@"bg_thumb2.png"]]];
            }
            else {
                [item setImage:[PaintUtility imageNamedFromContentFile:[kPDFReaderStyle1Bundle stringByAppendingPathComponent:@"bg_thumb1.png"]]];
            }
        }
    }
}

-(void)drawTouchBegin
{

}
//接受PDF传过来的没有可以取消的笔画的命令，然后让取消按钮失效
-(void)noneDrawPath
{

}

//接收PDF传过来的点击页面中部的事件，如果点击中部，在PDF的下部初始化一个ToolBar，出现翻页按钮
-(void)touchInTheMiddle
{
/*
    [UIView beginAnimations:@"" context:NULL];
    [UIView setAnimationDuration:0.5];
    [pageToolBar setAlpha:pageToolBar.alpha<=0.0?0.8:0.0];
    [pageHighlightedLabel setAlpha:pageHighlightedLabel.alpha<=0.0?0.8:0.0];
    
    [titleLabel setAlpha:titleLabel.alpha<=0.0?1.0:0.0];
    
    [UIView commitAnimations];
 */

}

- (void)scrollTurnPageRefresh
{
    [self refreshPageToolBar];
}

- (void)dealloc {

    self.delegate = nil;
    self.displayDelegate = nil;
    
    [document release];
    document=nil;
    
	if(toolbarImageVIew) {
        [toolbarImageVIew release];
        toolbarImageVIew=nil;
    }
	if(titleLabel) {
        [titleLabel release];
        titleLabel=nil;
    }
    if(pageToolBar) {//下方直接翻页的工具栏
        [pageToolBar release];
        pageToolBar=nil;
    }
    if(pageHighlightedLabel) {//翻页时显示页码
        [pageHighlightedLabel release];
        pageHighlightedLabel=nil;
    }

	if(pdfScrollView) {
        [pdfScrollView release];
        pdfScrollView=nil;
    }
    
    [permissionDictionary release];
    permissionDictionary = nil;
    
    [touchView release];
    [touchImageView release];

    [super dealloc];
}

#pragma mark -
#pragma mark PDFFuncToolbarDelegate methods

- (void)tappedInFuncToolbar:(PDFFuncToolbar *)toolbar backButton:(UIButton *)button {
    
    if ([_delegate respondsToSelector:@selector(tappedInPDFToolbar:backButton:)]) {
        
        [_delegate tappedInPDFToolbar:toolbar backButton:button];
    }
    
    [self dismissPDFToolViewController];
}

- (void)tappedInFuncToolbar:(PDFFuncToolbar *)toolbar infoButton:(UIButton *)button {
    
    if ([_delegate respondsToSelector:@selector(tappedInPDFToolbar:infoButton:)]) {
        
        [_delegate tappedInPDFToolbar:toolbar infoButton:button];
    }
}

- (void)tappedInFuncToolbar:(PDFFuncToolbar *)toolbar sendButton:(UIButton *)button {
    
    if ([_delegate respondsToSelector:@selector(tappedInPDFToolbar:sendButton:)]) {
        
        [_delegate tappedInPDFToolbar:toolbar sendButton:button];
    }
}

- (void)tappedInFuncToolbar:(PDFFuncToolbar *)toolbar helpButton:(UIButton *)button {
    
    if (signToolbar.isHidden) {//浏览状态
        
        helpImageView.image = [PaintUtility imageNamedFromContentFile:[kPDFReaderStyle1Bundle stringByAppendingPathComponent:@"bg_browseHelp_1.png"]];
    }
    else {
        
        helpImageView.image = [PaintUtility imageNamedFromContentFile:[kPDFReaderStyle1Bundle stringByAppendingPathComponent:@"bg_signHelp_2.png"]];
    }
    
    [self.view addSubview:helpImageView];
    
    [UIView animateWithDuration:0.5 animations:^{
        [helpImageView setAlpha:1.0];
    }];
}
- (void)tappedInFuncToolbar:(PDFFuncToolbar *)toolbar rotateButton:(UIButton *)button {
    
    if ([[pdfScrollView getDrawingView] getIsEdit]) {
        UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@"提示"
                                                            message:@"由于横宽比例不同，翻转会导致之前签批内容消失，是否继续？"
                                                           delegate:self
                                                  cancelButtonTitle:@"取消"
                                                  otherButtonTitles:@"继续",nil];
        alertView.tag = kAlertViewFlipConfirm;
        [alertView show];
        [alertView release];
    }
    else {
        [pdfScrollView flipBackgroundImageView];
    }
}

- (void)tappedInFuncToolbar:(PDFFuncToolbar *)toolbar accessoryButton:(UIButton *)button
{
    if ([_delegate respondsToSelector:@selector(tappedInPDFToolbar:accessoryButton:)]) {
        
        [_delegate tappedInPDFToolbar:toolbar accessoryButton:button];
    }
}

- (void)tappedInFuncToolbar:(PDFFuncToolbar *)toolbar checkButton:(UIButton *)button
{
    if ([_delegate respondsToSelector:@selector(tappedInPDFToolbar:checkButton:)]) {
        
        [_delegate tappedInPDFToolbar:toolbar checkButton:button];
    }
}

#pragma mark -
#pragma mark - PDFBrowseToolbarDelegate methods

- (void)tappedInSignToolbar:(PDFBrowseToolbar *)toolbar startSignButton:(UIButton *)button {
    
    if ([_delegate respondsToSelector:@selector(tappedInPDFToolbar:startSignButton:)]) {
        
        [_delegate tappedInPDFToolbar:toolbar startSignButton:button];
    }
    
    [self startSign];
}

- (void)tappedInSignToolbar:(PDFBrowseToolbar *)toolbar previousButton:(UIButton *)button {
    
    [pdfScrollView previousPage];
    
    [self refreshPageToolBar];
}

- (void)tappedInSignToolbar:(PDFBrowseToolbar *)toolbar nextButton:(UIButton *)button {
    
    [pdfScrollView nextPage];
    
    [self refreshPageToolBar];
}

#pragma mark -
#pragma mark - BottomBarViewDelegate methods

- (void)selectOperate:(id)sender
{
    UIButton *btn = (UIButton *)sender;
    
    switch (btn.tag)
    {
        case operateType_rotate:
        {
            if ([[pdfScrollView getDrawingView] getIsEdit]) {
                UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@"提示"
                                                                    message:@"由于横宽比例不同，翻转会导致之前签批内容消失，是否继续？"
                                                                   delegate:self
                                                          cancelButtonTitle:@"取消"
                                                          otherButtonTitles:@"继续",nil];
                alertView.tag = kAlertViewFlipConfirm;
                [alertView show];
                [alertView release];
            }
            else {
                [pdfScrollView flipBackgroundImageView];
            }
            
            break;
        }
            
        case operateType_nextPage:
        {
            
            [pdfScrollView nextPage];
            
            [self refreshPageToolBar];
            
            break;
        }
            
        case operateType_lastPage:
        {
            [pdfScrollView previousPage];
            
            [self refreshPageToolBar];
            
            break;
        }
            
        case operateType_help:
        {
            BottomBarView *barView = (BottomBarView *)[[btn superview] superview];
            
            if (barView.fourTab == YES) {//四个tab选择
                
                helpImageView.image = [PaintUtility imageNamedFromContentFile:[kPDFReaderStyle1Bundle stringByAppendingPathComponent:@"help_4.png"]];
            }
            else {
                
                helpImageView.image = [PaintUtility imageNamedFromContentFile:[kPDFReaderStyle1Bundle stringByAppendingPathComponent:@"help_5.png"]];
            }
            
            [self.view addSubview:helpImageView];
            
            [UIView animateWithDuration:0.5 animations:^{
                [helpImageView setAlpha:1.0];
            }];
            
            break;
        }
            
        case operateType_checkAccessory:
        {
            if ([_delegate respondsToSelector:@selector(tappedInPDFToolbar:checkButton:)]) {
                
                [_delegate tappedInPDFToolbar:nil checkButton:nil];
            }
            
            break;
        }
            
            
        default:
            break;
    }
    
//    [pdfScrollView setZoomScale:1.25 animated:YES];
}

#pragma mark -
#pragma mark - PDFSignToolbarDelegate methods

- (void)tappedInSignToolbar:(PDFSignToolbar *)toolbar endSignButton:(UIButton *)button {
    
    if ([_delegate respondsToSelector:@selector(tappedInPDFToolbar:endSignButton:)]) {
        
        [_delegate tappedInPDFToolbar:toolbar endSignButton:button];
    }
    
    [self endSign];
}

- (void)tappedInSignToolbar:(PDFSignToolbar *)toolbar colorButton:(UIButton *)button color:(UIColor *)color {
    
    CGFloat red;
    CGFloat green;
    CGFloat blue;
    CGFloat alpha;
    
   
    [color getRed:&red green:&green blue:&blue alpha:&alpha];

    //add by lixiangai
    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];

    [userDefaults
     setObject:[NSString stringWithFormat:@"%f,%f,%f,%f,%d",red,green,blue,alpha,(int)(button.tag)]
    forKey:@"paintbrushColor"];
    
    [userDefaults synchronize];
    
    //end
    
    [[pdfScrollView getDrawingView] setChangedScaleFactor:1.0];
    
    [[pdfScrollView getDrawingView] setBrushColorWithRed:red green:green blue:blue];
}

- (void)tappedInSignToolbar:(PDFSignToolbar *)toolbar sizeButton:(UIButton *)button level:(NSInteger)level {
    
    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
    [userDefaults setObject:[NSString stringWithFormat:@"%d",level] forKey:@"paintbrushSize"];
    
    [userDefaults synchronize];
    
    [[pdfScrollView getDrawingView] setBruchScaleLevel:level];
    
}

- (void)tappedInSignToolbar:(PDFSignToolbar *)toolbar clearButton:(UIButton *)button {
    
    
    UIImageView *bgImageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 400, 200)];
    
    bgImageView.image = [UIImage imageNamed:[kPDFReaderStyle1Bundle stringByAppendingPathComponent:@"bg_alert_style1.png"]];
    
//    CustomAlertView *alertView = [[CustomAlertView alloc] initWithBackgroundView:bgImageView];
    CustomNewAlertView *alertView = [[CustomNewAlertView alloc] initWithTitle:@"" message:@"" delegate:nil cancelButtonTitle:nil otherButtonTitles:nil];
    
    
    //描述信息
    UILabel *titleLab = [[UILabel alloc] initWithFrame:CGRectMake(0, 5, bgImageView.frame.size.width, 50)];
    titleLab.text = @"提示";
    titleLab.font = [UIFont boldSystemFontOfSize:22];
    titleLab.textAlignment = UITextAlignmentCenter;
    [titleLab setTextColor:[UIColor whiteColor]];
    [titleLab setBackgroundColor:[UIColor clearColor]];
    [alertView addTheview:titleLab];
    [titleLab release];
    
    UILabel *contentLab = [[UILabel alloc] initWithFrame:CGRectMake(20, 50, 360, 80)];
    contentLab.text = @"笔迹清空后，将无法恢复";
    contentLab.font = [UIFont boldSystemFontOfSize:16];
    contentLab.numberOfLines = 2;
    contentLab.textAlignment = UITextAlignmentCenter;
    [contentLab setTextColor:[UIColor colorWithHex:@"474747"]];
    [contentLab setBackgroundColor:[UIColor whiteColor]];
    [alertView addTheview:contentLab];
    [contentLab release];
    

    UIButton *doneButton = [UIButton buttonWithType:UIButtonTypeCustom];
    doneButton.frame = CGRectMake(20, 140, 130, 40);
    [doneButton setTitle:@"确定" forState:UIControlStateNormal];
    [doneButton setTitleColor:[UIColor colorWithHex:@"3b6f92"] forState:UIControlStateNormal];
    [doneButton setBackgroundImage:[UIImage imageNamed:[kPDFReaderStyle1Bundle stringByAppendingPathComponent:@"button_blue_style1.png"]] forState:UIControlStateNormal];
    [doneButton addTarget:self action:@selector(clearDrawingBoard) forControlEvents:UIControlEventTouchUpInside];
    [alertView addButton:doneButton];
    
    UIButton *cancelButton = [UIButton buttonWithType:UIButtonTypeCustom];
    [cancelButton setTitle:@"取消" forState:UIControlStateNormal];
    [cancelButton setTitleColor:[UIColor colorWithHex:@"3b6f92"] forState:UIControlStateNormal];
    [cancelButton setBackgroundImage:[UIImage imageNamed:[kPDFReaderStyle1Bundle stringByAppendingPathComponent:@"button_blue_style1.png"]] forState:UIControlStateNormal];
    cancelButton.frame = CGRectMake(250, 140, 130, 40);

    [alertView addButton:cancelButton];
    
    
    [alertView show:self.view];
    
    [bgImageView release];
    [alertView release];
    
    
}
- (void)tappedInSignToolbar:(PDFSignToolbar *)toolbar eraseButton:(UIButton *)button {
    
	[[pdfScrollView getDrawingView] eraseWithTransparent];
}

- (void)tappedInSignToolbar:(PDFSignToolbar *)toolbar undoButton:(UIButton *)button {
    
    
}
- (void)tappedInSignToolbar:(PDFSignToolbar *)toolbar redoButton:(UIButton *)button {
    
    
}

#ifdef __IPHONE_6_0
#if __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_5_0
-(NSUInteger)supportedInterfaceOrientations{
    
    return UIInterfaceOrientationMaskPortrait;
}

-(BOOL)shouldAutorotate{
    
    return NO;
}
#endif
#endif

@end
