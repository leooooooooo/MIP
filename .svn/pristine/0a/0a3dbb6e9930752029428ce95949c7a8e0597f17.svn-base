//
//  MultiFoldawayTableView.m
//  MOA
//
//  Created by Sea on 13-5-27.
//
//

#import "MultiFoldawayTableView.h"

@interface MultiFoldawayTableView (Override)

//TODO: 重载父类的方法,如果之前没有获取数据，或者获取的数据为0条时，重新请求数据 该方法将在此时触发
- (void)unfoldDataInSection:(NSInteger)section;

@end

@implementation MultiFoldawayTableView

@synthesize dataList;
@synthesize foldNum;

- (void)setDataList:(NSArray *)nDataList {
    
    if (dataList != nDataList) {
        [dataList release];
        dataList = [nDataList retain];
        
        _currentEntity = nil;//此处数据源重新获取新值,将之前记录的一些状态清空
    }
}

//TODO: 重载父类的方法,如果之前没有获取数据，或者获取的数据为0条时，重新请求数据 该方法将在此时触发
- (void)unfoldDataInSection:(NSInteger)section {
    
    //子类可以重载此方法来获取数据
}

- (id)initWithFrame:(CGRect)frame style:(UITableViewStyle)style
{
    self = [super initWithFrame:frame style:style];
    if (self) {
        // Initialization code
        
        [self setCanCancelContentTouches:YES];
        
        [self setDelaysContentTouches:NO];
        
        
        self.sectionHeaderHeight = 80;
        
        _subCellHeight = 100.0;
        
        self.separatorStyle = UITableViewCellSeparatorStyleNone;
    }
    return self;
}

//TODO: 用于处理嵌套UITableView滑动的一些细节处理
- (BOOL)touchesShouldBegin:(NSSet *)touches withEvent:(UIEvent *)event inContentView:(UIView *)view {
    
    UITouch *touch = [touches anyObject];
    CGPoint currentTouchPosition = [touch locationInView :self];
    NSIndexPath *indexPath = [self indexPathForRowAtPoint : currentTouchPosition];
    
    if (indexPath && ![view isKindOfClass:[FoldawaySectionHeaderView class]]) {
        
        self.scrollEnabled = NO;
        
        double delayInSeconds = 0.25;
        dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));
        dispatch_after(popTime, dispatch_get_main_queue(), ^(void){
            
            self.scrollEnabled = YES;
        });
        
        return YES;
    }
    
    return [super touchesShouldBegin:touches withEvent:event inContentView:view];
}

- (void)dealloc {
    
    _currentEntity = nil;
    
    self.dataList = nil;
    
    [super dealloc];
}

//TODO: 计算每一行row的高度,该row将会放置一个UITableView，实现UITableView的嵌套
- (CGFloat)calculateHeightForRowAtIndexPath:(NSIndexPath *)indexPath {
    
    CGRect frame = self.bounds;
    
    if (self.dataList.count == 0) {//如果没有section
        
        return 0;
    }
    else if (self.dataList.count == 1) {//只有一个section
        
        CGFloat sectionHeight = self.sectionHeaderHeight;
        
        CGFloat maxValidHeight = frame.size.height - sectionHeight;
        
        return maxValidHeight;
    }
    else {
        
        CGFloat sectionHeight = self.sectionHeaderHeight;
        
        CGFloat maxValidHeight = frame.size.height - 2*sectionHeight;
        
        FoldawayEntity *entity = [self.dataList objectAtIndex:indexPath.section];
        
        CGFloat allRowHeight = _subCellHeight*entity.entryList.count;
        
        return allRowHeight < maxValidHeight ? allRowHeight : maxValidHeight;
    }
    
    return 0;
}

//TODO: 返回UITableView的section总数
- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {
    
    return dataList.count;
}

//TODO: 返回每一个section的自定义视图
- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section
{
    FoldawaySectionHeaderView   *sectionHeaderView = [[FoldawaySectionHeaderView alloc] initWithFrame:CGRectMake(0, 0, self.bounds.size.width, self.sectionHeaderHeight) section:section];
    
    sectionHeaderView.sectionHeaderDelegate = self;
    
    return [sectionHeaderView autorelease];
}

//TODO: 每一行section下row的高度
- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {
    
    return [self calculateHeightForRowAtIndexPath:indexPath];
}



//TODO: 返回每一个section下row的数量     当section展开时为1,当section缩起时,为0    由于row展开时只有一行,因此在该row上重新放置一个UITableView
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    
    FoldawayEntity  *entity = [self.dataList objectAtIndex:section];
    
    if (entity.isFolded && entity.entryList.count > 0) {
        return 1;
    }
    else
        return 0;
}


//TODO: 初始化cell上的放置的UITableView
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    
    static NSString *CellIdentifier = @"MultiFoldawayCell";
    
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];
    if (cell == nil) {
        
        CGFloat height = [self tableView:tableView heightForRowAtIndexPath:indexPath];
        
        cell = [[[SubTableViewStyleCell alloc] initWithSubTableViewClass:[UITableView class] reuseIdentifier:CellIdentifier cellSize:CGSizeMake(self.frame.size.width, height)] autorelease];
    }
    
    return cell;
}

/*
// Only override drawRect: if you perform custom drawing.
// An empty implementation adversely affects performance during animation.
- (void)drawRect:(CGRect)rect
{
    // Drawing code
}
*/

#pragma mark --
#pragma mark FoldawaySectionHeader delegate methods

//TODO: 点击section视图时,伸缩或缩起视图        
//由于UI操作需要在主线程中执行,因此无法使用runtime来通过挂起线程的方式来控制线程的挂起与执行,目前使用任务管理,来控制主队列的挂起与执行,不影响主线程的正常使用
- (void)foldawaySectionHeaderViewClicked:(BOOL)isFolded section:(NSInteger)section target:(FoldawaySectionHeaderView *)headerView{
    self.foldNum = section;
    
    FoldawayEntity  *newEntity = [self.dataList objectAtIndex:section];
    
    newEntity.isFolded = isFolded;
    
    dispatch_group_t taskGroup = dispatch_group_create();//创建一个任务组
    
    dispatch_queue_t mainQueue = dispatch_get_main_queue();
    
    dispatch_queue_t concurrentQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    
    dispatch_group_async(taskGroup, concurrentQueue, ^{//分配该组的任务,并且异步执行
        
        if (isFolded) {
            
            if (newEntity.entryList.count == 0) {//展开时，如果发现之前获取过数据则不再获取，如果之前没有获取数据，或者获取的数据为0条时，重新请求数据
                
                [self unfoldDataInSection:section];
            }
        }
    });
    
    dispatch_group_notify(taskGroup, mainQueue, ^{//当上面组内任务全部完成之时,该方法体将开始执行
        
        //用于展开或者收起列表
        NSMutableArray *insertIndexPaths = [[NSMutableArray alloc] init];
        NSMutableArray *deleteIndexPaths = [[NSMutableArray alloc] init];
        
        if (isFolded) {//展开自身栏目,并收起其他展开栏目
            
            if (newEntity.entryList.count > 0) {//只有其含有子数据的时候,才展开列表
                
                [insertIndexPaths addObject:[NSIndexPath indexPathForRow:0 inSection:section]];
            }
            
            NSLog(@"%@",_currentEntity);
            
            if (_currentEntity) {//修改上次展开的栏目,并收起
                
                _currentEntity.isFolded = NO;
                _currentEntity.headerView.isFolded = NO;
                
                if (_currentEntity.entryList.count > 0) {
                    
                    [deleteIndexPaths addObject:[NSIndexPath indexPathForRow:0 inSection:_currentEntity.headerView.section]];//同展开,只有其含有子数据的时候,才会收起
                }
            }
            
            _currentEntity = newEntity;
        }
        else {//收起自身的栏目

            if (_currentEntity.entryList.count > 0) {
                
                 [deleteIndexPaths addObject:[NSIndexPath indexPathForRow:0 inSection:section]];
            }
            
            _currentEntity = nil;
        }
        
        
        if (insertIndexPaths.count > 0 || deleteIndexPaths.count > 0) {
            
            [self beginUpdates];
            
            if (insertIndexPaths.count > 0) {
                
                [self insertRowsAtIndexPaths:insertIndexPaths withRowAnimation:UITableViewRowAnimationMiddle];
            }
            
            if (deleteIndexPaths.count > 0) {
                
                [self deleteRowsAtIndexPaths:deleteIndexPaths withRowAnimation:UITableViewRowAnimationMiddle];
            }
            
            [self endUpdates];
        }

        //计算该行sectionView需要滑动的距离
        
        if (insertIndexPaths.count > 0) {
            
            [self scrollToRowAtIndexPath:[NSIndexPath indexPathForRow:0 inSection:section] atScrollPosition:UITableViewScrollPositionTop animated:YES];
        }
        
        [insertIndexPaths release];
        [deleteIndexPaths release];
        
    });
    
    dispatch_release(taskGroup);//释放创建的任务组
}

@end
