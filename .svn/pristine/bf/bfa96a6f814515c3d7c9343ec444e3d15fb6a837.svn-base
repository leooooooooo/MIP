/*
     File: PaintingView.m
 Abstract: The class responsible for the finger painting. The class wraps the 
 CAEAGLLayer from CoreAnimation into a convenient UIView subclass. The view 
 content is basically an EAGL surface you render your OpenGL scene into.
  Version: 1.11
 
 Disclaimer: IMPORTANT:  This Apple software is supplied to you by Apple
 Inc. ("Apple") in consideration of your agreement to the following
 terms, and your use, installation, modification or redistribution of
 this Apple software constitutes acceptance of these terms.  If you do
 not agree with these terms, please do not use, install, modify or
 redistribute this Apple software.
 
 In consideration of your agreement to abide by the following terms, and
 subject to these terms, Apple grants you a personal, non-exclusive
 license, under Apple's copyrights in this original Apple software (the
 "Apple Software"), to use, reproduce, modify and redistribute the Apple
 Software, with or without modifications, in source and/or binary forms;
 provided that if you redistribute the Apple Software in its entirety and
 without modifications, you must retain this notice and the following
 text and disclaimers in all such redistributions of the Apple Software.
 Neither the name, trademarks, service marks or logos of Apple Inc. may
 be used to endorse or promote products derived from the Apple Software
 without specific prior written permission from Apple.  Except as
 expressly stated in this notice, no other rights or licenses, express or
 implied, are granted by Apple herein, including but not limited to any
 patent rights that may be infringed by your derivative works or by other
 works in which the Apple Software may be incorporated.
 
 The Apple Software is provided by Apple on an "AS IS" basis.  APPLE
 MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION
 THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS
 FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND
 OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS.
 
 IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL
 OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION,
 MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED
 AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE),
 STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE
 POSSIBILITY OF SUCH DAMAGE.
 
 Copyright (C) 2010 Apple Inc. All Rights Reserved.
 
*/

#import <QuartzCore/QuartzCore.h>
#import <OpenGLES/EAGLDrawable.h>

#import "PaintingView.h"

#import "PaintUtility.h"

//add by gyf begin
#import <math.h>
//add by gyf end

//CLASS IMPLEMENTATIONS:

static NSTimeInterval   lastTouch = 0;

// A class extension to declare private methods
@interface PaintingView (private)

- (BOOL)createFramebuffer;
- (void)destroyFramebuffer;

@end

@implementation PaintingView

@synthesize  location;
@synthesize  previousLocation;

//add by gyf begin
@synthesize  changeFlag;
@synthesize  prepreviousLocation;
@synthesize  nextLocation;
@synthesize	 previousTimeStamp,timeSincePrevious,firstTimeStamp,lastTimeStamp;
@synthesize  brushwidth,scaleFactor,pointCounts;

@synthesize  changedScaleFactor;
@synthesize	 isEndTouch,isRealZooming;
@synthesize currentBrushScaleLevel;

@synthesize currentBorderX,isMoveMargin;
//add by gyf end

// Implement this to override the default layer class (which is [CALayer class]).
// We do this so that our view will be backed by a layer that is capable of OpenGL ES rendering.
+ (Class) layerClass
{
	return [CAEAGLLayer class];
}

// The GL view is stored in the nib file. When it's unarchived it's sent -initWithCoder:
- (id)initWithCoder:(NSCoder*)coder {
	
	//NSMutableArray*	recordedPaths;
	CGImageRef		brushImage;
	CGContextRef	brushContext;
	GLubyte			*brushData;
	size_t			width, height;
    
    if ((self = [super initWithCoder:coder])) {
		CAEAGLLayer *eaglLayer = (CAEAGLLayer *)self.layer;
		
		eaglLayer.opaque = YES;
		// In this application, we want to retain the EAGLDrawable contents after a call to presentRenderbuffer.
		eaglLayer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:
										[NSNumber numberWithBool:YES], kEAGLDrawablePropertyRetainedBacking, kEAGLColorFormatRGBA8, kEAGLDrawablePropertyColorFormat, nil];
		
		context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES1];
		
		if (!context || ![EAGLContext setCurrentContext:context]) {
			[self release];
			return nil;
		}
		
		// Create a texture from an image
		// First create a UIImage object from the data in a image file, and then extract the Core Graphics image
		brushImage = [UIImage imageNamed:[kPDFReaderStyle1Bundle stringByAppendingPathComponent:@"Particle5.png"]].CGImage;
		
		// Get the width and height of the image
		width = CGImageGetWidth(brushImage);
		height = CGImageGetHeight(brushImage);
		
		// Texture dimensions must be a power of 2. If you write an application that allows users to supply an image,
		// you'll want to add code that checks the dimensions and takes appropriate action if they are not a power of 2.
		
		// Make sure the image exists
		if(brushImage) {
			// Allocate  memory needed for the bitmap context
			brushData = (GLubyte *) calloc(width * height * 4, sizeof(GLubyte));
			// Use  the bitmatp creation function provided by the Core Graphics framework. 
			brushContext = CGBitmapContextCreate(brushData, width, height, 8, width * 4, CGImageGetColorSpace(brushImage), kCGImageAlphaPremultipliedLast);
			// After you create the context, you can draw the  image to the context.
			CGContextDrawImage(brushContext, CGRectMake(0.0, 0.0, (CGFloat)width, (CGFloat)height), brushImage);
			// You don't need the context at this point, so you need to release it to avoid memory leaks.
			CGContextRelease(brushContext);
			// Use OpenGL ES to generate a name for the texture.
			glGenTextures(1, &brushTexture);
			// Bind the texture name. 
			glBindTexture(GL_TEXTURE_2D, brushTexture);
			// Set the texture parameters to use a minifying filter and a linear filer (weighted average)
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
			// Specify a 2D texture image, providing the a pointer to the image data in memory
			glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, brushData);
			// Release  the image data; it's no longer needed
            free(brushData);
		}
		
		// Set the view's scale factor
		self.contentScaleFactor = 1.0;
	
		// Setup OpenGL states
		glMatrixMode(GL_PROJECTION);
		CGRect frame = self.bounds;
		CGFloat scale = self.contentScaleFactor;
		// Setup the view port in Pixels
		glOrthof(0, frame.size.width * scale, 0, frame.size.height * scale, -1, 1);
		glViewport(0, 0, frame.size.width * scale, frame.size.height * scale);
		glMatrixMode(GL_MODELVIEW);
		
		glDisable(GL_DITHER);
		glEnable(GL_TEXTURE_2D);
		glEnableClientState(GL_VERTEX_ARRAY);
		
	    glEnable(GL_BLEND);
		// Set a blending function appropriate for premultiplied alpha pixel data
		glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
		
		glEnable(GL_POINT_SPRITE_OES);
		glTexEnvf(GL_POINT_SPRITE_OES, GL_COORD_REPLACE_OES, GL_TRUE);
		glPointSize(width / kBrushScale);
		self.brushwidth = width;
		self.scaleFactor = -1.0;
        currentScale = kBrushScale;
		// Make sure to start with a cleared buffer
		needsErase = YES;
		//[self setBrushColorWithRed:kRed green:kGreeen blue:kBlue];
		// Playback recorded path, which is "Shake Me"
		/*
		recordedPaths = [NSMutableArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"Recording" ofType:@"data"]];
		if([recordedPaths count])
			[self performSelector:@selector(playback:) withObject:recordedPaths afterDelay:0.2];
		//*/
		//初始化路径记录
        
        //[self scrollViewDidEndZooming:nil withView:nil atScale:kInitSignScale];
        NSString *paramMaxRecordPathCount = @"5";
        maxRecordPathCount = [paramMaxRecordPathCount intValue];
        if (maxRecordPathCount <= 0) {
            maxRecordPathCount = 10;
        }
		recordPath = [[NSMutableArray alloc] initWithCapacity:maxRecordPathCount];
		currentRecordPathCount = 0;
		isEndTouch = TRUE;
        [self setMultipleTouchEnabled:NO];
        isEdit = NO;
        //undoStorkeImage = [[NSMutableArray alloc] initWithCapacity:maxRecordPathCount];
        //undoImageView = [[UIImageView alloc] initWithFrame:self.frame];
        //undoImageView.userInteractionEnabled = NO;
        //undoImageView.backgroundColor = [UIColor clearColor];
	}
	
	return self;
}

//add by gyf begin
// if the GL view is not stored in the nib file. use this to init.
- (id)initWithFrame:(CGRect)frame {
	
	//modified by gyf begin
	//NSMutableArray*	recordedPaths;
	changedScaleFactor = 1.0;
	//modified by gyf end
	CGImageRef		brushImage;
	CGContextRef	brushContext;
	GLubyte			*brushData;
	size_t			width, height;
    
    if ((self = [super initWithFrame:frame])) {
		CAEAGLLayer *eaglLayer = (CAEAGLLayer *)self.layer;
		
		eaglLayer.opaque = YES;
		// In this application, we want to retain the EAGLDrawable contents after a call to presentRenderbuffer.
		eaglLayer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:
										[NSNumber numberWithBool:YES], kEAGLDrawablePropertyRetainedBacking, kEAGLColorFormatRGBA8, kEAGLDrawablePropertyColorFormat, nil];
		
		context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES1];
		
		if (!context || ![EAGLContext setCurrentContext:context]) {
			[self release];
			return nil;
		}
		
		// Create a texture from an image
		// First create a UIImage object from the data in a image file, and then extract the Core Graphics image
        
        brushImage = [UIImage imageNamed:[kPDFReaderStyle1Bundle stringByAppendingPathComponent:@"Particle5.png"]].CGImage;
        
		
		// Get the width and height of the image
		width = CGImageGetWidth(brushImage);
		height = CGImageGetHeight(brushImage);
		
		// Texture dimensions must be a power of 2. If you write an application that allows users to supply an image,
		// you'll want to add code that checks the dimensions and takes appropriate action if they are not a power of 2.
		
		// Make sure the image exists
		if(brushImage) {
			// Allocate  memory needed for the bitmap context
			brushData = (GLubyte *) calloc(width * height * 4, sizeof(GLubyte));
			// Use  the bitmatp creation function provided by the Core Graphics framework. 
			brushContext = CGBitmapContextCreate(brushData, width, height, 8, width * 4, CGImageGetColorSpace(brushImage), kCGImageAlphaPremultipliedLast);
			// After you create the context, you can draw the  image to the context.
			CGContextDrawImage(brushContext, CGRectMake(0.0, 0.0, (CGFloat)width, (CGFloat)height), brushImage);
			// You don't need the context at this point, so you need to release it to avoid memory leaks.
			CGContextRelease(brushContext);
			// Use OpenGL ES to generate a name for the texture.
			glGenTextures(1, &brushTexture);
			// Bind the texture name. 
			glBindTexture(GL_TEXTURE_2D, brushTexture);
			// Set the texture parameters to use a minifying filter and a linear filer (weighted average)
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
			// Specify a 2D texture image, providing the a pointer to the image data in memory
			glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, brushData);
			// Release  the image data; it's no longer needed
            free(brushData);
		}
		
		// Set the view's scale factor
		self.contentScaleFactor = 1.0;
		
		// Setup OpenGL states
		glMatrixMode(GL_PROJECTION);
        CGRect frame = self.bounds;
        CGFloat scale = self.contentScaleFactor;
        // Setup the view port in Pixels
        glOrthof(0, frame.size.width * scale, 0, frame.size.height * scale, -1, 1);
        glViewport(0, 0, frame.size.width * scale, frame.size.height * scale);

		glMatrixMode(GL_MODELVIEW);
		
		glDisable(GL_DITHER);
		glEnable(GL_TEXTURE_2D);
		glEnableClientState(GL_VERTEX_ARRAY);
		
	    glEnable(GL_BLEND);
		// Set a blending function appropriate for premultiplied alpha pixel data
		glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
		
		glEnable(GL_POINT_SPRITE_OES);
		glTexEnvf(GL_POINT_SPRITE_OES, GL_COORD_REPLACE_OES, GL_TRUE);
		glPointSize(width / kBrushScale);
        
		self.brushwidth = width;
        
        currentScale = kBrushScale;
        
		// Make sure to start with a cleared buffer
		needsErase = YES;
		//初始化路径记录
        
        NSString *paramMaxRecordPathCount = @"5";
        maxRecordPathCount = [paramMaxRecordPathCount intValue];
        if (maxRecordPathCount <= 0) {
            maxRecordPathCount = 5;
        }
		recordPath = [[NSMutableArray alloc] initWithCapacity:maxRecordPathCount];
        lastRecord = [[NSMutableData alloc] init];

		currentRecordPathCount = 0;
		isEndTouch = TRUE;
		//isRealZooming = FALSE;//初始化的时候不让其缩放
		isRealZooming = TRUE;
		[self refreshParticle];
        isEdit = NO;
        [self setMultipleTouchEnabled:NO];
        isMoveMargin = NO;
	}
	
	return self;
}

- (void)refreshFrame
{
    CGRect frame = self.bounds;
    CGFloat scale = self.contentScaleFactor;
    // Setup the view port in Pixels
    glOrthof(0, frame.size.width * scale, 0, frame.size.height * scale, -1, 1);
    glViewport(0, 0, frame.size.width * scale, frame.size.height * scale);
}

//add by gyf end

// If our view is resized, we'll be asked to layout subviews.
// This is the perfect opportunity to also update the framebuffer so that it is
// the same size as our display area.
-(void)layoutSubviews
{
	[EAGLContext setCurrentContext:context];
	if (needsErase)
	{
        [self destroyFramebuffer];
	}
	if (needsErase) {
		[self createFramebuffer];
	}
	
	// Clear the framebuffer the first time it is allocated
	if (needsErase) {
		[self erase];
		needsErase = NO;
	}
}

- (BOOL)createFramebuffer
{
	// Generate IDs for a framebuffer object and a color renderbuffer
	glGenFramebuffersOES(1, &viewFramebuffer);
	glGenRenderbuffersOES(1, &viewRenderbuffer);
	
	glBindFramebufferOES(GL_FRAMEBUFFER_OES, viewFramebuffer);
	glBindRenderbufferOES(GL_RENDERBUFFER_OES, viewRenderbuffer);
	// This call associates the storage for the current render buffer with the EAGLDrawable (our CAEAGLLayer)
	// allowing us to draw into a buffer that will later be rendered to screen wherever the layer is (which corresponds with our view).
    
	[context renderbufferStorage:GL_RENDERBUFFER_OES fromDrawable:(id<EAGLDrawable>)self.layer];
	glFramebufferRenderbufferOES(GL_FRAMEBUFFER_OES, GL_COLOR_ATTACHMENT0_OES, GL_RENDERBUFFER_OES, viewRenderbuffer);
	
	glGetRenderbufferParameterivOES(GL_RENDERBUFFER_OES, GL_RENDERBUFFER_WIDTH_OES, &backingWidth);
	glGetRenderbufferParameterivOES(GL_RENDERBUFFER_OES, GL_RENDERBUFFER_HEIGHT_OES, &backingHeight);
	
	// For this sample, we also need a depth buffer, so we'll create and attach one via another renderbuffer.
	glGenRenderbuffersOES(1, &depthRenderbuffer);
	glBindRenderbufferOES(GL_RENDERBUFFER_OES, depthRenderbuffer);
	glRenderbufferStorageOES(GL_RENDERBUFFER_OES, GL_DEPTH_COMPONENT16_OES, backingWidth, backingHeight);
	glFramebufferRenderbufferOES(GL_FRAMEBUFFER_OES, GL_DEPTH_ATTACHMENT_OES, GL_RENDERBUFFER_OES, depthRenderbuffer);
	
	if(glCheckFramebufferStatusOES(GL_FRAMEBUFFER_OES) != GL_FRAMEBUFFER_COMPLETE_OES)
	{
		NSLog(@"failed to make complete framebuffer object %x", glCheckFramebufferStatusOES(GL_FRAMEBUFFER_OES));
		return NO;
	}
	return YES;
}

// Clean up any buffers we have allocated.
- (void)destroyFramebuffer
{
	//NSLog(@"destroyFramebuffer");
	glDeleteFramebuffersOES(1, &viewFramebuffer);
	viewFramebuffer = 0;
	glDeleteRenderbuffersOES(1, &viewRenderbuffer);
	viewRenderbuffer = 0;
	
	if(depthRenderbuffer)
	{
		glDeleteRenderbuffersOES(1, &depthRenderbuffer);
		depthRenderbuffer = 0;
	}
}

// Releases resources when they are not longer needed.
- (void) dealloc
{
    
    //add by zhoumin begin
    if (lastRecord) {
        [lastRecord release];
    }
    //add by zhoumin end
	if (brushTexture)
	{
		glDeleteTextures(1, &brushTexture);
		brushTexture = 0;
	}
	
	if([EAGLContext currentContext] == context)
	{
		[EAGLContext setCurrentContext:nil];
	}
	
	[context release];
    if (recordPath) {
        [recordPath release];
    }
//    if (undoStorkeImage) {
//        [undoStorkeImage release];
//    }
    if (currentDrawImage) {
        [currentDrawImage release];
    }
//    if (undoImageView) {
//        [undoImageView release];
//    }
	[super dealloc];
}

// Erases the screen
//清空页面
- (void) erase
{
	[EAGLContext setCurrentContext:context];
	
	// Clear the buffer
	glBindFramebufferOES(GL_FRAMEBUFFER_OES, viewFramebuffer);
	//modified by gyf begin
	glClearColor(0.0, 0.0, 0.0, 0.0);
	//glClearColor(0.5f, 0.5f, 0.5f, 0.3f);
	//modified by gyf end
	glClear(GL_COLOR_BUFFER_BIT);
	
	// Display the buffer
	glBindRenderbufferOES(GL_RENDERBUFFER_OES, viewRenderbuffer);
	[context presentRenderbuffer:GL_RENDERBUFFER_OES];
    
    if (currentDrawImage) {
        [currentDrawImage release];
        currentDrawImage = nil;
    }
    if (self.subviews && [self.subviews count]>0) {
        [[self.subviews objectAtIndex:0] removeFromSuperview];
    }
//    if (undoStorkeImage) {
//        [undoStorkeImage removeAllObjects];
//    }
    currentRecordPathCount = 0;
    isEndTouch = TRUE;
    
}

//清空页面
- (void) eraseForUndo
{
	[EAGLContext setCurrentContext:context];
	
	// Clear the buffer
	glBindFramebufferOES(GL_FRAMEBUFFER_OES, viewFramebuffer);
	//modified by gyf begin
	glClearColor(0.0, 0.0, 0.0, 0.0);
	//glClearColor(0.5f, 0.5f, 0.5f, 0.3f);
	//modified by gyf end
	glClear(GL_COLOR_BUFFER_BIT);
	
	// Display the buffer
	glBindRenderbufferOES(GL_RENDERBUFFER_OES, viewRenderbuffer);
	[context presentRenderbuffer:GL_RENDERBUFFER_OES];
    isEndTouch = TRUE;
    
}
// Drawings a line onscreen based on where the user touches
- (void) renderLineFromPointForPlayBack:(CGPoint)start toPoint:(CGPoint)end
{
	//add by gyf begin
	//NSLog(@"renderLineFromPointSub2: %@,%@", NSStringFromCGPoint(start), NSStringFromCGPoint(end));
	//add by gyf end
	
	static GLfloat*		vertexBuffer = NULL;
	static NSUInteger	vertexMax = 64;
	NSUInteger			vertexCount = 0,
	count,
	i;
	
	[EAGLContext setCurrentContext:context];
	glBindFramebufferOES(GL_FRAMEBUFFER_OES, viewFramebuffer);
	
	// Convert locations from Points to Pixels
	CGFloat scale = self.contentScaleFactor;
	start.x *= scale;
	start.y *= scale;
	end.x *= scale;
	end.y *= scale;
	
	// Allocate vertex array buffer
	if(vertexBuffer == NULL)
		vertexBuffer = malloc(vertexMax * 2 * sizeof(GLfloat));
	
	// Add points to the buffer so there are drawing points every X pixels
	count = MAX(ceilf(sqrtf((end.x - start.x) * (end.x - start.x) + (end.y - start.y) * (end.y - start.y)) / kBrushPixelStep), 1);
	//NSLog(@"count:%d",count);
	for(i = 0; i < count; ++i) {
		if(vertexCount == vertexMax) {
			vertexMax = 2 * vertexMax;
			vertexBuffer = realloc(vertexBuffer, vertexMax * 2 * sizeof(GLfloat));
		}
		
		vertexBuffer[2 * vertexCount + 0] = start.x + (end.x - start.x) * ((GLfloat)i / (GLfloat)count);
		vertexBuffer[2 * vertexCount + 1] = start.y + (end.y - start.y) * ((GLfloat)i / (GLfloat)count);
		
		//NSLog(@"vertexBuffer[%d]:%f",2 * vertexCount + 0,vertexBuffer[2 * vertexCount + 0]);
		//NSLog(@"vertexBuffer[%d]:%f",2 * vertexCount + 1,vertexBuffer[2 * vertexCount + 1]);
		
		vertexCount += 1;
	}
	
	//add by gyf begin
	//show different color each array
	/*
	 self.changeFlag = (!self.changeFlag);
	 if(self.changeFlag){
	 [self setBrushColorWithRed:255 green:0 blue:0];
	 }
	 else{
	 [self setBrushColorWithRed:0 green:0 blue:255];
	 }
	 //*/
	//add by gyf end
	//重新设置笔画粗细, 防止因为前面很细导致这边也很细, 因为这是一个全局变量
	glPointSize(self.brushwidth / currentScale);
	// Render the vertex array
	glVertexPointer(2, GL_FLOAT, 0, vertexBuffer);
	glDrawArrays(GL_POINTS, 0, vertexCount);
	
	// Display the buffer
	glBindRenderbufferOES(GL_RENDERBUFFER_OES, viewRenderbuffer);
	//NSLog(@"viewRenderbuffer: %d",viewRenderbuffer);
	[context presentRenderbuffer:GL_RENDERBUFFER_OES];
	//glBindRenderbufferOES(GL_FRAMEBUFFER_OES, viewRenderbuffer);
	//[context presentRenderbuffer:GL_FRAMEBUFFER_OES];
}
// Drawings a line onscreen based on where the user touches
- (void) renderLineFromPoint:(CGPoint)start toPoint:(CGPoint)end
{
	//add by gyf begin
	//NSLog(@"renderLineFromPointSub2: %@,%@", NSStringFromCGPoint(start), NSStringFromCGPoint(end));
	//add by gyf end
	
	static GLfloat*		vertexBuffer = NULL;
	static NSUInteger	vertexMax = 64;
	NSUInteger			vertexCount = 0,
	count,
	i;
	
	[EAGLContext setCurrentContext:context];
	glBindFramebufferOES(GL_FRAMEBUFFER_OES, viewFramebuffer);
	
	// Convert locations from Points to Pixels
	CGFloat scale = self.contentScaleFactor;
	start.x *= scale;
	start.y *= scale;
	end.x *= scale;
	end.y *= scale;
	
	// Allocate vertex array buffer
	if(vertexBuffer == NULL)
		vertexBuffer = malloc(vertexMax * 2 * sizeof(GLfloat));
	
	// Add points to the buffer so there are drawing points every X pixels
	count = MAX(ceilf(sqrtf((end.x - start.x) * (end.x - start.x) + (end.y - start.y) * (end.y - start.y)) / kBrushPixelStep), 1);
	//NSLog(@"count:%d",count);
	for(i = 0; i < count; ++i) {
		if(vertexCount == vertexMax) {
			vertexMax = 2 * vertexMax;
			vertexBuffer = realloc(vertexBuffer, vertexMax * 2 * sizeof(GLfloat));
		}
		
		vertexBuffer[2 * vertexCount + 0] = start.x + (end.x - start.x) * ((GLfloat)i / (GLfloat)count);
		vertexBuffer[2 * vertexCount + 1] = start.y + (end.y - start.y) * ((GLfloat)i / (GLfloat)count);
		
		//NSLog(@"vertexBuffer[%d]:%f",2 * vertexCount + 0,vertexBuffer[2 * vertexCount + 0]);
		//NSLog(@"vertexBuffer[%d]:%f",2 * vertexCount + 1,vertexBuffer[2 * vertexCount + 1]);
		
		vertexCount += 1;
	}
	
	//add by gyf begin
	//show different color each array
	/*
	self.changeFlag = (!self.changeFlag);
	if(self.changeFlag){
		[self setBrushColorWithRed:255 green:0 blue:0];
	}
	else{
		[self setBrushColorWithRed:0 green:0 blue:255];
	}
	//*/
	//add by gyf end
	//重新设置笔画粗细, 防止因为前面很细导致这边也很细, 因为这是一个全局变量
	glPointSize(self.brushwidth / currentScale);
	// Render the vertex array
	glVertexPointer(2, GL_FLOAT, 0, vertexBuffer);
	glDrawArrays(GL_POINTS, 0, vertexCount);
	
	// Display the buffer
	glBindRenderbufferOES(GL_RENDERBUFFER_OES, viewRenderbuffer);
	//NSLog(@"viewRenderbuffer: %d",viewRenderbuffer);
	[context presentRenderbuffer:GL_RENDERBUFFER_OES];
	//glBindRenderbufferOES(GL_FRAMEBUFFER_OES, viewRenderbuffer);
	//[context presentRenderbuffer:GL_FRAMEBUFFER_OES];
	//记录入手写路径
    if (lastRecord) {
        [lastRecord appendBytes:&start length:sizeof(CGPoint)];
        [lastRecord appendBytes:&end length:sizeof(CGPoint)];
    }
}

//add by gyf begin
// Drawings a line onscreen based on where the user touches
- (void) renderLineFromPoint:(CGPoint)start toPoint:(CGPoint)end speed:(CGFloat)speed
{
	//NSLog(@"renderLineFromPointMainSub1: %@,%@", NSStringFromCGPoint(start), NSStringFromCGPoint(end));
	//add by gyf begin
	//NSLog(@"%@,%@", NSStringFromCGPoint(start), NSStringFromCGPoint(end));
	//add by gyf end
	
	static GLfloat*		vertexBuffer = NULL;
	static NSUInteger	vertexMax = 64;
	NSUInteger			vertexCount = 0,
	count,
	i;
	
	[EAGLContext setCurrentContext:context];
	glBindFramebufferOES(GL_FRAMEBUFFER_OES, viewFramebuffer);
	
	// Convert locations from Points to Pixels
	CGFloat scale = self.contentScaleFactor;
	start.x *= scale;
	start.y *= scale;
	end.x *= scale;
	end.y *= scale;
	
	// Allocate vertex array buffer
	if(vertexBuffer == NULL)
		vertexBuffer = malloc(vertexMax * 2 * sizeof(GLfloat));
	
	// Add points to the buffer so there are drawing points every X pixels
	count = MAX(ceilf(sqrtf((end.x - start.x) * (end.x - start.x) + (end.y - start.y) * (end.y - start.y)) / kBrushPixelStep), 1);
	for(i = 0; i < count; ++i) {
		if(vertexCount == vertexMax) {
			vertexMax = 2 * vertexMax;
			vertexBuffer = realloc(vertexBuffer, vertexMax * 2 * sizeof(GLfloat));
		}
		
		vertexBuffer[2 * vertexCount + 0] = start.x + (end.x - start.x) * ((GLfloat)i / (GLfloat)count);
		vertexBuffer[2 * vertexCount + 1] = start.y + (end.y - start.y) * ((GLfloat)i / (GLfloat)count);
		//NSLog(@"vertexBuffer[%d]:%f",2 * vertexCount + 0,vertexBuffer[2 * vertexCount + 0]);
		//NSLog(@"vertexBuffer[%d]:%f",2 * vertexCount + 1,vertexBuffer[2 * vertexCount + 1]);
		vertexCount += 1;
	}
	
	//add by gyf begin
	//show different color each array
	/*
	 self.changeFlag = (!self.changeFlag);
	 if(self.changeFlag){
	 [self setBrushColorWithRed:255 green:0 blue:0];
	 }
	 else{
	 [self setBrushColorWithRed:0 green:0 blue:255];
	 }
	 //*/
	//[self setBrushColorWithRed:0 green:0 blue:0 speed:speed];
	//add by gyf end
	
	// Render the vertex array
	[self setBruchScale:speed];
	glVertexPointer(2, GL_FLOAT, 0, vertexBuffer);
	glDrawArrays(GL_POINTS, 0, vertexCount);
	
	// Display the buffer
	glBindRenderbufferOES(GL_RENDERBUFFER_OES, viewRenderbuffer);
	[context presentRenderbuffer:GL_RENDERBUFFER_OES];
	//记录入手写路径
    if (lastRecord) {
        [lastRecord appendBytes:&start length:sizeof(CGPoint)];
        [lastRecord appendBytes:&end length:sizeof(CGPoint)];
    }
}

// Drawings a line onscreen based on where the user touches
- (void) renderLineFromPoint:(CGPoint)start toPoint:(CGPoint)end controlPoint1:(CGPoint)cp1 controlPoint2:(CGPoint)cp2 speed:(CGFloat)speed
{
	//add by gyf begin
	//NSLog(@"renderLineFromPointMain: %@,%@,cp:%@,%@", NSStringFromCGPoint(start), NSStringFromCGPoint(end),NSStringFromCGPoint(cp1),NSStringFromCGPoint(cp2));
	//add by gyf end
	
	static GLfloat*		vertexBuffer = NULL;
	static NSUInteger	vertexMax = 64;
	NSUInteger			vertexCount = 0,
	count,
	i;
	GLfloat				u = 0.0;
	[EAGLContext setCurrentContext:context];
	glBindFramebufferOES(GL_FRAMEBUFFER_OES, viewFramebuffer);
	
	// Convert locations from Points to Pixels
	CGFloat scale = self.contentScaleFactor;
	start.x *= scale;
	start.y *= scale;
	end.x *= scale;
	end.y *= scale;
	
	// Allocate vertex array buffer
	if(vertexBuffer == NULL)
		vertexBuffer = malloc(vertexMax * 2 * sizeof(GLfloat));
	
	// Add points to the buffer so there are drawing points every X pixels
	count = MAX(ceilf(sqrtf((end.x - start.x) * (end.x - start.x) + (end.y - start.y) * (end.y - start.y)) / kBrushPixelStep), 1);
	//NSLog(@"count:%d",count);
	for(i = 0; i < count; ++i) {
		if(vertexCount == vertexMax) {
			vertexMax = 2 * vertexMax;
			vertexBuffer = realloc(vertexBuffer, vertexMax * 2 * sizeof(GLfloat));
		}
		///*
		u = (GLfloat)i / (GLfloat)count;
		vertexBuffer[2 * vertexCount + 0] = pow(u,3)*(end.x+3*(cp1.x-cp2.x)-start.x)+3*pow(u,2)*(start.x-2*cp1.x+cp2.x)+3*u*(cp1.x-start.x)+start.x;
		vertexBuffer[2 * vertexCount + 1] = pow(u,3)*(end.y+3*(cp1.y-cp2.y)-start.y)+3*pow(u,2)*(start.y-2*cp1.y+cp2.y)+3*u*(cp1.y-start.y)+start.y;
		//*/
		
		vertexCount += 1;
		
	}
	
	//add by gyf begin
	//show different color each array
	/*
	self.changeFlag = (!self.changeFlag);
	if(self.changeFlag){
		[self setBrushColorWithRed:255 green:0 blue:0];
	}
	else{
		[self setBrushColorWithRed:0 green:0 blue:255];
	}
	//*/
	//add by gyf end
	
	// Render the vertex array
	[self setBruchScale:speed];
	glVertexPointer(2, GL_FLOAT, 0, vertexBuffer);
	glDrawArrays(GL_POINTS, 0, vertexCount);
	
	// Display the buffer
	glBindRenderbufferOES(GL_RENDERBUFFER_OES, viewRenderbuffer);
	[context presentRenderbuffer:GL_RENDERBUFFER_OES];
	//记录入手写路径
    if (lastRecord) {
        [lastRecord appendBytes:&start length:sizeof(CGPoint)];
        [lastRecord appendBytes:&end length:sizeof(CGPoint)];
    }
}
//add by gyf end
- (void) playback:(NSMutableArray*)recordedPaths //new
{
	CGPoint start = CGPointMake(41, 296);
	CGPoint end = CGPointMake(20, 284);
	CGPoint cp1 = CGPointMake(33.2, 292);
	CGPoint cp2 = CGPointMake(25, 287);
	//[self renderLineFromPoint:start toPoint:end  speed:0.0];
	[self renderLineFromPoint:start toPoint:end  controlPoint1:cp1 controlPoint2:cp2 speed:0.0];
	start = CGPointMake(20, 284);
	end = CGPointMake(16, 281);
	cp1 = CGPointMake(15, 281);
	cp2 = CGPointMake(17, 281.8);
	//[self renderLineFromPoint:start toPoint:end speed:0.0];
	[self renderLineFromPoint:start toPoint:end  controlPoint1:cp1 controlPoint2:cp2 speed:0.0];
}
- (void) refreshParticle//刷新画笔采样频率
{
	NSMutableArray *recordedPaths = [NSMutableArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"Recording" ofType:@"data"]];
	if([recordedPaths count])
		[self performSelector:@selector(playback_old:) withObject:recordedPaths afterDelay:0.2];
}
// Reads previously recorded points and draws them onscreen. This is the Shake Me message that appears when the application launches.
- (void) playback_old:(NSMutableArray*)recordedPaths
{
	NSData*				data = [recordedPaths objectAtIndex:0];
	CGPoint*			point = (CGPoint*)[data bytes];
	NSUInteger			count = [data length] / sizeof(CGPoint),
						i;
	glBlendFunc(GL_ONE, GL_ZERO);
	//the erase brush color  is transparent.
	glColor4f(0, 0, 0, 0.0);
	for(i = 0; i < count - 1; ++i, ++point)
	{
		[self renderLineFromPointForPlayBack:*point toPoint:*(point + 1)];
	}
	glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
	[self setBrushColorWithRed:currentRed green:currentGreen blue:currentBlue];
	// Render the next path after a short delay 
	//*/
    
    
}
- (BOOL)getIsEdit
{
    return isEdit;
}

- (void)setIsEdit:(BOOL)isEditValue
{
    isEdit = isEditValue;
}
// Handles the start of a touch
- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    isEdit = YES;
    isMoveMargin = NO;
	//NSLog(@"Touch Began count:%d",[touches count]);
	CGRect bounds = [self bounds];
    UITouch* touch = [[event touchesForView:self] anyObject];
	firstTouch = YES;
	// Convert touch point from UIView referential to OpenGL one (upside-down flip)
	location = [touch locationInView:self];
	location.y = bounds.size.height - location.y;
    
    //向上滑动手势相关的
    isInCenterMargin = YES;//向上滑动取消相关
	startPoint = location;//向上滑动取消相关
    previousPoint = location;//向上滑动取消相关
    //相关结束
    
	//add by gyf begin
	self.previousTimeStamp = event.timestamp;
	self.scaleFactor = -1.0;//为了速度因素的初始值置位，这很重要
	self.pointCounts = 1;
	//NSLog(@"Touch Began Point: %@, Current Time: %f ",NSStringFromCGPoint(location),event.timestamp);
	self.firstTimeStamp = event.timestamp;
	//add by gyf end

	isEndTouch = FALSE;
    [self.paintViewDelegate touchBegin];
    
    if (lastRecord) {
        [lastRecord release];
        lastRecord = nil;
        lastRecord = [[NSMutableData alloc] init];
    }
}

- (CGPoint) LineDataAnalyse:(CGPoint)prepreLocation preLocation:(CGPoint)preLocation curlocation:(CGPoint)curlocation neLocation:(CGPoint)neLocation  
{
    CGPoint newLocation;
    newLocation.x = 0;
    newLocation.y = 0;
    
    float sum_x = prepreLocation.x+preLocation.x+curlocation.x+neLocation.x;
    float sum_y = prepreLocation.y+preLocation.y+curlocation.y+neLocation.y;
    float sum_xx = prepreLocation.x*prepreLocation.x+preLocation.x*preLocation.x+curlocation.x*curlocation.x+neLocation.x*neLocation.x;
    float sum_yy = prepreLocation.y*prepreLocation.y+preLocation.y*preLocation.y+curlocation.y*curlocation.y+neLocation.y*neLocation.y;
    float sum_xy = prepreLocation.x*prepreLocation.y+preLocation.x*preLocation.y+curlocation.x*curlocation.y+neLocation.x*neLocation.y;
    float a1 = (4*sum_xy-sum_x*sum_y)/(4*sum_xx-sum_x*sum_x);
    float a0 = (sum_y-a1*sum_x)/4;
    if (a1<=1 && a1>=-1) {
        float newlocation_y = a0+a1*curlocation.x;
        if (fabsf(newlocation_y-curlocation.y)<2) {
            //curlocation.y = newlocation_y;
            newLocation.x =curlocation.x;
            newLocation.y = newlocation_y;
        }
    } else {
        float a3 = (4*sum_xy-sum_x*sum_y)/(4*sum_yy-sum_y*sum_y);
        float a2 = (sum_x-a3*sum_y)/4;
        if (a3<=1 && a3>=-1) {
            float newlocation_x = a2+a3*curlocation.y;
            if (fabsf(newlocation_x-curlocation.x)<2) {
                //curlocation.x = newlocation_x;
                newLocation.x = newlocation_x;
                newLocation.y = curlocation.y;
            }
        }
    }
    return newLocation;
}

- (CGPoint) NonlineDataAnalyse:(CGPoint)prepreLocation preLocation:(CGPoint)preLocation curlocation:(CGPoint)curlocation neLocation:(CGPoint)neLocation  
{
    CGPoint newLocation;
    newLocation.x = 0;
    newLocation.y = 0;
    
    float sum_xxy = prepreLocation.x*prepreLocation.x*prepreLocation.y+preLocation.x*preLocation.x*preLocation.y+curlocation.x*curlocation.x*curlocation.y+neLocation.x*neLocation.x*neLocation.y;
    float sum_xx = prepreLocation.x*prepreLocation.x+preLocation.x*preLocation.x+curlocation.x*curlocation.x+neLocation.x*neLocation.x;
    float sum_y = prepreLocation.y+preLocation.y+curlocation.y+neLocation.y;
    float sum_x = prepreLocation.x+preLocation.x+curlocation.x+neLocation.x;
    float sum_xy = prepreLocation.x*prepreLocation.y+preLocation.x*preLocation.y+curlocation.x*curlocation.y+neLocation.x*neLocation.y;
    float sum_xxx = prepreLocation.x*prepreLocation.x*prepreLocation.x+preLocation.x*preLocation.x*preLocation.x+curlocation.x*curlocation.x*curlocation.x+neLocation.x*neLocation.x*neLocation.x;
    float sum_xxxx = prepreLocation.x*prepreLocation.x*prepreLocation.x*prepreLocation.x+preLocation.x*preLocation.x*preLocation.x*preLocation.x+curlocation.x*curlocation.x*curlocation.x*curlocation.x+neLocation.x*neLocation.x*neLocation.x*neLocation.x;
    
    float a1 = ((4*sum_xxy-sum_xx*sum_y)*(4*sum_xx-sum_x*sum_x)-(4*sum_xy-sum_x*sum_y)*(4*sum_xxx-sum_x*sum_xx))/((4*sum_xxxx-sum_xx*sum_xx)*(4*sum_xx-sum_x*sum_x)-(4*sum_xxx-sum_x*sum_xx)*(4*sum_xxx-sum_x*sum_xx));
    float a2 = (4*sum_xx*sum_y-sum_y*sum_xx-a1*(4*sum_xxxx-sum_xx*sum_xx))/(4*sum_xxx-sum_x*sum_xx);
    float a3 = (sum_y-a1*sum_xx-a2*sum_x)/4;
    
    float newlocation_y = a1*curlocation.x*curlocation.x+a2*curlocation.x+a3;
    if (fabsf(newlocation_y-curlocation.y)<2) {
        //curlocation.y = newlocation_y;
        newLocation.x = curlocation.x;
        newLocation.y = newlocation_y;
    }
    return newLocation;
}

// Handles the continuation of a touch.
- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
{  
    
	//NSLog(@"Touch Moved count:%d",[touches count]);
	CGRect				bounds = [self bounds];
	UITouch*			touch = [[event touchesForView:self] anyObject];
    
    
	pointCounts++;
	//add by gyf begin
	
	//add by gyf end
	//use bezier algorithm
	Boolean isBezier = FALSE;
	if (firstTouch) {
		//add by gyf begin
		//fix the first isolated dot bug
		location = [touch locationInView:self];
	    location.y = bounds.size.height - location.y;
		//add by gyf end
		previousLocation = [touch previousLocationInView:self];
		previousLocation.y = bounds.size.height - previousLocation.y;
		//开始计算第-1个点
		prepreviousLocation = [PaintUtility getNagetivePointByCurrentPoints:location previousPoint:previousLocation];
		//NSLog(@"Touch Move First CurrentPoint: %@, PreviousPoint: %@",NSStringFromCGPoint(location),NSStringFromCGPoint(previousLocation));
	} else {
		isBezier = TRUE;
		nextLocation = [touch locationInView:self];
		nextLocation.y = bounds.size.height - nextLocation.y;
		//NSLog(@"nextLocation%@",NSStringFromCGPoint(nextLocation));
	}
	//根据速度设置笔画的粗细
	//[self setBruchScale:speed];
	if(firstTouch)
	{
		firstTouch = NO;
	}
	else {
		CGFloat distance = sqrt((location.x-previousLocation.x)*(location.x-previousLocation.x) + (location.y-previousLocation.y)*(location.y-previousLocation.y));
		CGFloat speed = distance/timeSincePrevious;
		if (distance <= kMaxPixelWithoutBezier) { //当两点间的距离小于一定的像素时,不适用贝塞尔曲线拟合
			isBezier = FALSE;
		}
        //NSLog(@"location.x:   %f location.y:   %f",location.x,location.y);
        
        //NSLog(@"斜率: %f",(location.y-previousLocation.y)/(location.x-previousLocation.x));
        float linevariance;
        float nonlinevariance;
        
        CGPoint curlocation = [self LineDataAnalyse:prepreviousLocation preLocation:previousLocation curlocation:location neLocation:nextLocation];
        CGPoint curlocation_non = [self NonlineDataAnalyse:prepreviousLocation preLocation:previousLocation curlocation:location neLocation:nextLocation];
        
        if (curlocation.x!=0 && curlocation_non.x!=0) {
            linevariance = (curlocation.x- location.x)*(curlocation.x-location.x)+(curlocation.y-location.y)*(curlocation.y-location.y);
            nonlinevariance = (curlocation_non.x- location.x)*(curlocation_non.x-location.x)+(curlocation_non.y-location.y)*(curlocation_non.y-location.y);
            if (linevariance <= nonlinevariance) {
                location = curlocation;
            } else {
                location = curlocation_non;
            }
        } else if (curlocation.x!=0 && curlocation_non.x==0) {
            location = curlocation;
        } else if (curlocation.x==0 && curlocation_non.x!=0) {
            location = curlocation_non;
        }
        //NSLog(@"newlocation.x:%f newlocation.y:%f",location.x,location.y);
        
		if(isBezier){
			//NSLog(@"Distance: %f, speed: %f; (Bezier)",distance,speed);
			CGPoint ctrlPoint1,ctrlPoint2;
			[PaintUtility computeBezierControlPointBy4PointsP0:prepreviousLocation p1:previousLocation p2:location p3:nextLocation 
															 c1:&ctrlPoint1 c2:&ctrlPoint2];
			[self renderLineFromPoint:previousLocation toPoint:location controlPoint1:ctrlPoint1 controlPoint2:ctrlPoint2 speed:speed];
			//画完一笔后给堆栈赋值
			prepreviousLocation.x = previousLocation.x;
			prepreviousLocation.y = previousLocation.y;
			previousLocation.x = location.x;
			previousLocation.y = location.y;
			location.x = nextLocation.x;
			location.y = nextLocation.y;
		}
		else {
			CGPoint ctrlPoint1,ctrlPoint2;
			[PaintUtility computeBezierControlPointBy4PointsP0:prepreviousLocation p1:previousLocation p2:location p3:nextLocation 
															 c1:&ctrlPoint1 c2:&ctrlPoint2];
			
			//NSLog(@"Distance: %f, speed: %f; (No Bezier)",distance,speed);
			[self renderLineFromPoint:previousLocation toPoint:location speed:speed];
			prepreviousLocation.x = previousLocation.x;
			prepreviousLocation.y = previousLocation.y;
			previousLocation.x = location.x;
			previousLocation.y = location.y;
			location.x = nextLocation.x;
			location.y = nextLocation.y;
		}
	}
	timeSincePrevious = event.timestamp - self.previousTimeStamp;
	//reset previousTimeStamp
	self.previousTimeStamp = event.timestamp;
	
	//add by gyf end
	//*/

}

// Handles the end of a touch event when the touch is a tap.
- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event
{
	//NSLog(@"Touch Ended");
	CGRect				bounds = [self bounds];
    UITouch*	touch = [[event touchesForView:self] anyObject];

	//reset previousTimeStamp
	self.previousTimeStamp = event.timestamp;
	self.lastTimeStamp = event.timestamp;
	if (firstTouch) {
		//firstTouch = NO;
		location = [touch locationInView:self];
	    location.y = bounds.size.height - location.y;
		//add by gyf end
		previousLocation = [touch previousLocationInView:self];
		previousLocation.y = bounds.size.height - previousLocation.y;
		
		//当开始点和结束点重合的时候, 人工帮其补N个像素的点, 使其看起来更像是一个点, 而不是一个痕迹
		//在此也不需要计算速度, 因为速度显然是0, 所以粗细度也会很细的
		if (ABS(previousLocation.x - location.x) < kMinPointTouchPixel ) {
			location.x = location.x + kMinPointTouchPixel;
		}
		if (ABS(previousLocation.y - location.y) < kMinPointTouchPixel) {
			location.y = location.y - kMinPointTouchPixel;
		}
		
		//NSLog(@"Touch Ended First CurrentPoint: %@, PreviousPoint: %@",NSStringFromCGPoint(location),NSStringFromCGPoint(previousLocation));
		[self renderLineFromPoint:previousLocation toPoint:location];
	}
	else {
		//先要补足倒数第二笔少画的哦
		Boolean isBezier = TRUE;
		nextLocation = [touch locationInView:self];
		nextLocation.y = bounds.size.height - nextLocation.y;
		CGFloat distance = sqrt((location.x-previousLocation.x)*(location.x-previousLocation.x) + (location.y-previousLocation.y)*(location.y-previousLocation.y));
		CGFloat speed = distance/timeSincePrevious;
		if (distance <= kMaxPixelWithoutBezier) { //当两点间的距离小于一定的像素时,不适用贝塞尔曲线拟合
			isBezier = FALSE;
		}
		if(isBezier){
			CGPoint ctrlPoint1,ctrlPoint2;
			[PaintUtility computeBezierControlPointBy4PointsP0:prepreviousLocation p1:previousLocation p2:location p3:nextLocation 
															 c1:&ctrlPoint1 c2:&ctrlPoint2];
			[self renderLineFromPoint:previousLocation toPoint:location controlPoint1:ctrlPoint1 controlPoint2:ctrlPoint2 speed:speed];
			//NSLog(@"Touch Ended 之前一笔(贝塞尔): %@, PreviousPoint: %@, CurrentTime: %f",NSStringFromCGPoint(location),
			//	  NSStringFromCGPoint(previousLocation),event.timestamp);
			//画完一笔后给堆栈赋值
			prepreviousLocation.x = previousLocation.x;
			prepreviousLocation.y = previousLocation.y;
			previousLocation.x = location.x;
			previousLocation.y = location.y;
			location.x = nextLocation.x;
			location.y = nextLocation.y;
		}
		else {
			[self renderLineFromPoint:previousLocation toPoint:location speed:speed];
			//NSLog(@"Touch Ended 之前一笔(不用贝塞尔): %@, PreviousPoint: %@, CurrentTime: %f",NSStringFromCGPoint(location),
			//	  NSStringFromCGPoint(previousLocation),event.timestamp);
			prepreviousLocation.x = previousLocation.x;
			prepreviousLocation.y = previousLocation.y;
			previousLocation.x = location.x;
			previousLocation.y = location.y;
			location.x = nextLocation.x;
			location.y = nextLocation.y;
		}
		
		//然后再画最后一笔
		timeSincePrevious = event.timestamp - self.previousTimeStamp;
		
		CGPoint templocation = [touch locationInView:self];
	    templocation.y = bounds.size.height - templocation.y;
		//add by gyf end
		CGPoint temppreviousLocation = [touch previousLocationInView:self];
		temppreviousLocation.y = bounds.size.height - temppreviousLocation.y;
		distance = sqrt((templocation.x-temppreviousLocation.x)*(templocation.x-temppreviousLocation.x) + (templocation.y-temppreviousLocation.y)*(templocation.y-temppreviousLocation.y));
		speed = distance/timeSincePrevious;
		//最后一笔都不应该用贝塞尔, 等待验证
		[self renderLineFromPoint:temppreviousLocation toPoint:templocation speed:speed];
		/*
		if (distance <= kMaxPixelWithoutBezier) { //当两点间的距离小于一定的像素时,不适用贝塞尔曲线拟合
			[self renderLineFromPoint:temppreviousLocation toPoint:templocation speed:speed];
			NSLog(@"Touch Ended 最后一笔(不用贝塞尔): %@, PreviousPoint: %@",NSStringFromCGPoint(templocation),NSStringFromCGPoint(temppreviousLocation));
		}
		else {	//贝塞尔曲线
			nextLocation = [CommonUtility getPostivePointByCurrentPoints:templocation previousPoint:temppreviousLocation];
			//nextLocation = [CommonUtility getPostivePointByCurrentPoints:templocation previousPoint:temppreviousLocation];
			CGPoint ctrlPoint1,ctrlPoint2;
			[CommonUtility computeBezierControlPointBy4PointsP0:prepreviousLocation p1:previousLocation p2:location p3:nextLocatiosn 
															 c1:&ctrlPoint1 c2:&ctrlPoint2];
			
			NSLog(@"Touch Ended 最后一笔(贝塞尔): %@, PreviousPoint: %@",NSStringFromCGPoint(location),NSStringFromCGPoint(previousLocation));
			[self renderLineFromPoint:previousLocation toPoint:location controlPoint1:ctrlPoint1 controlPoint2:ctrlPoint2 speed:speed];
		}
		 */
	}
	NSLog(@"采样频率: %f",(self.lastTimeStamp - self.firstTimeStamp) / self.pointCounts);
    //[self saveUndoImageInBackground];
	//开始保存图片
    //[self performSelectorOnMainThread:@selector(saveUndoImageInBackground) withObject:nil waitUntilDone:NO];
    //[self performSelectorInBackground:@selector(saveUndoImageInBackground:) withObject:self];
    
    /*
    UIImage *drawImage = nil;

    if (currentDrawImage) {//如果之前有暂存的图片，则将暂存的图片和现有图片合并成为新的图片
        drawImage = [CommonUtility addTwoImageToOne:currentDrawImage twoImage:[self glToUIImage]];
    }
    else {
        if (undoImageView.image) {
            drawImage = [CommonUtility addTwoImageToOne:undoImageView.image twoImage:[self glToUIImage]];
        }
        else {
            NSLog(@"before glToUIImage Time: %@",[CommonUtility getCurrentTimeByFormat:@"HH:mm:ss.SSS"]);
            drawImage = [self glToUIImage];
            NSLog(@"after glToUIImage A Time: %@",[CommonUtility getCurrentTimeByFormat:@"HH:mm:ss.SSS"]);
        }
    }

    if (currentRecordPathCount >= maxRecordPathCount) {
        if (undoStorkeImage && [undoStorkeImage count] >= 1) {
            if (currentDrawImage) {
                [currentDrawImage release];
            }
            currentDrawImage = [[undoStorkeImage objectAtIndex:0] copy];
            [undoStorkeImage removeObjectAtIndex:0];
            currentRecordPathCount--;
            [undoStorkeImage addObject:drawImage];
            //[undoStorkeImage insertObject:drawImage atIndex:currentRecordPathCount];
        }
    }
    else {
        [undoStorkeImage addObject:drawImage];
        //[undoStorkeImage insertObject:drawImage atIndex:currentRecordPathCount];
        
    }
    NSLog(@"after glToUIImage B Time: %@",[CommonUtility getCurrentTimeByFormat:@"HH:mm:ss.SSS"]);
     */

    //结束路径
	//currentRecordPathCount++;
	isEndTouch = TRUE;
    if (lastRecord) {
        [lastRecord release];
        lastRecord = nil;
        lastRecord = [[NSMutableData alloc] init];
    }
    //added by mhj 2013.6.28 begin
    NSTimeInterval nowT = [[NSDate date]   timeIntervalSince1970];
    if (abs(nowT-lastTouch)< 0.6)
    {
        lastTouch = nowT;
        return;
    }
    
    lastTouch = nowT;
    //added by mhj 2013.6.28 end
    if (location.x > currentBorderX) {
        isMoveMargin = YES;
        [self.paintViewDelegate inMoveMargin];
    }
    NSLog(@"Last Location: %@",NSStringFromCGPoint(location));
}
//在后台保存单步取消的图片
- (void)saveUndoImageInBackground
{
    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
     UIImage *drawImage = nil;
     
     if (currentDrawImage) {//如果之前有暂存的图片，则将暂存的图片和现有图片合并成为新的图片
         drawImage = [PaintUtility addTwoImageToOne:currentDrawImage twoImage:[self glToUIImage]];
     }
     else {
         if (undoImageView.image) {
             drawImage = [PaintUtility addTwoImageToOne:undoImageView.image twoImage:[self glToUIImage]];
         }
         else {

             drawImage = [self glToUIImage];
             NSString  *pngPath = [NSHomeDirectory() stringByAppendingPathComponent:[NSString stringWithFormat:@"Documents/Test%d.png",currentRecordPathCount]]; 
             [UIImagePNGRepresentation(drawImage) writeToFile:pngPath atomically:YES];

         }
     }
     
     if (currentRecordPathCount >= maxRecordPathCount) {
         if (undoStorkeImage && [undoStorkeImage count] >= 1) {
             if (currentDrawImage) {
                 [currentDrawImage release];
             }
             currentDrawImage = [[undoStorkeImage objectAtIndex:0] copy];
             [undoStorkeImage removeObjectAtIndex:0];
             currentRecordPathCount--;
             [undoStorkeImage addObject:drawImage];
             //[undoStorkeImage insertObject:drawImage atIndex:currentRecordPathCount];
         }
     }
     else {
         [undoStorkeImage addObject:drawImage];
         //[undoStorkeImage insertObject:drawImage atIndex:currentRecordPathCount];
     
     }
     //NSLog(@"after glToUIImage B Time: %@",[CommonUtility getCurrentTimeByFormat:@"HH:mm:ss.SSS"]);
     currentRecordPathCount++;
    [pool release];
}
//
// Handles the end of a touch event.
- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event
{
	// If appropriate, add code necessary to save the state of the application.
	// This application is not saving state.
}

- (void)setBrushColorWithRed:(CGFloat)red green:(CGFloat)green blue:(CGFloat)blue
{
	//add by gao_yufeng begin
	//恢复笔画颜色和混合类型
	// at last restore the  mixed-mode
	glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
	//add by gao_yufeng end
	
	// Set the brush color using premultiplied alpha values
	glColor4f(red	* kBrushOpacity,
			  green * kBrushOpacity,
			  blue	* kBrushOpacity,
			  kBrushOpacity);
	currentRed = red;
	currentGreen = green;
	currentBlue = blue;
	currentAlpha = kBrushOpacity;
}

//gyf add begin
- (void)eraseWithTransparent
{
	self.changedScaleFactor = kEraserSize;
	glColor4f(1.0f,1.0f,1.0f,1.0f);
	//modified by gao_yufeng begin
	//glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	//源色将覆盖目标色
	glBlendFunc(GL_ONE, GL_ZERO);
	//modified by gao_yufeng end
}

- (void)eraseWithWhite
{
	self.changedScaleFactor = kEraserSize;
	glColor4f(1.0f,1.0f,1.0f,1.0f);
	//modified by gao_yufeng begin
	//glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	//源色将覆盖目标色
	glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
	//modified by gao_yufeng end
}

//- (void)eraseWithWhite
//{
//	self.changedScaleFactor = kEraserSize;
//	glColor4f(1.0f,1.0f,1.0f,1.0f);
//	glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
//}

//reload method, append the param of speed
- (void)setBrushColorWithRed:(CGFloat)red green:(CGFloat)green blue:(CGFloat)blue speed:(CGFloat)speed
{
	//add by gao_yufeng begin
	//恢复笔画颜色和混合类型
	// at last restore the  mixed-mode
	glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
	//add by gao_yufeng end
	
	// Set the brush color using premultiplied alpha values
	glColor4f(red	* kBrushOpacity / speed * speedScale,
			  green * kBrushOpacity / speed * speedScale,
			  blue	* kBrushOpacity / speed * speedScale,
			  kBrushOpacity / speed * speedScale);
	glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
}
//gyf end

//set brush scale dynamicly with speed
- (void)setBruchScale:(CGFloat)speed
{
	CGFloat factor = kSpeedScaleX2 * ((speed / 10000) * (speed / 10000)) + kSpeedScaleX1 * (speed / 10000) + kSpeedScaleX0;
	if (self.scaleFactor >0 && ABS(self.scaleFactor - factor) > kMaxScaleInteval ) {
		factor = self.scaleFactor > factor ? self.scaleFactor - kMaxScaleInteval : self.scaleFactor + kMaxScaleInteval;
	}
	if(factor > kMaxRatioOfSpeedScale){
		factor = kMaxRatioOfSpeedScale;
	}

	
	//modified by gyf begin
	//glPointSize(self.brushwidth / kBrushScale / factor);
    //NSLog(@"changedScaleFactor: %f",changedScaleFactor);
	glPointSize(self.brushwidth / currentScale / factor * changedScaleFactor);
    //NSLog(@"factor is brushwidth: %f, kBrushScale:%d, factor:%f, changedScaleFactor:%f", self.brushwidth , kBrushScale , factor , changedScaleFactor);
	//modified by gyf end
	self.scaleFactor = factor;
}
//gyf end
//取消上一步画笔操作（新版，图片替代的方式，完美）
- (void) undoStokeForImage
{
    if ([undoStorkeImage count] >= currentRecordPathCount - 1) {
        [undoStorkeImage removeLastObject];
        currentRecordPathCount--;//先将之前那笔从数组中删除
    }
    else {
        return;
    }
    int undoStorkeImageCount = [undoStorkeImage count];
    if (undoStorkeImageCount > 0) {
//        if (currentDrawImage) {
//            [currentDrawImage release];
//        }
        int realCount = currentRecordPathCount - 1;
        UIImage *image = [[undoStorkeImage objectAtIndex:realCount] copy];
        
        //插入图片作为背景
        [undoImageView setImage:image];
        undoImageView.userInteractionEnabled = NO;
        undoImageView.backgroundColor = [UIColor clearColor];
        //如果之前已经有背景了，那么就删掉
//        if (self.subviews && [self.subviews count]>0) {
//            [[self.subviews objectAtIndex:0] removeFromSuperview];
//        }
        //[self addSubview:backImageView];
        //[self sendSubviewToBack:backImageView];
        //[backImageView release];
        [image release];
        //删除所有画笔
        [self eraseForUndo];
        //清空currentDrawImage和currentRecordPathCount
        //[undoStorkeImage removeAllObjects];
        //currentRecordPathCount = 0;
    }
    else {
        if (currentDrawImage) {
            [undoImageView setImage:currentDrawImage];
            //UIImageView *backImageView = [[UIImageView alloc] initWithImage:currentDrawImage];
            undoImageView.userInteractionEnabled = NO;
            undoImageView.backgroundColor = [UIColor clearColor];
            //如果之前已经有背景了，那么就删掉
//            if (self.subviews && [self.subviews count]>0) {
//                [[self.subviews objectAtIndex:0] removeFromSuperview];
//            }
//            [self addSubview:backImageView];
//            [self sendSubviewToBack:backImageView];
            //[backImageView release];
        }
        else {
            [undoImageView setImage:nil];
//            if (self.subviews && [self.subviews count]>0) {
//                [[self.subviews objectAtIndex:0] removeFromSuperview];
//            }
        }
        
        [self eraseForUndo];
    }
    if (currentRecordPathCount <= 0) {
        [self.paintViewDelegate noneDrawPath];//没有可以取消的了，要告诉它的代理
    }
}
//获取当前最新画板图片
- (UIImage *) getCurrentImage
{
    if (currentRecordPathCount>0 && [undoStorkeImage count]>= currentRecordPathCount) {
        return [undoStorkeImage objectAtIndex:currentRecordPathCount-1];
    }
    else {
        return nil;
    }
}
//获取当前取消ImageView
- (UIImageView *)getUndoImageView
{
    return undoImageView;
}
//取消上一步画笔操作（原版，路径取消重绘透明色的方式，不好）
- (void) undoLastStoke
{
	if (lastRecord) {
        CGPoint *point = (CGPoint*)[lastRecord bytes];
        NSUInteger count = [lastRecord length] / sizeof(CGPoint),i;
        if(count > 0)
        {
            //打开透明画笔
            //You need set the mixed-mode
            if (changedScaleFactor < kEraserSize) {//笔
                glBlendFunc(GL_ONE, GL_ZERO);
                //the erase brush color  is transparent.
                glColor4f(0, 0, 0, 0.0);
            }
            for(i = 0; i < count - 1; ++i, ++point)
            {
                [self drawErase:*point toPoint:*(point + 1)];
            }
            //恢复笔画颜色和混合类型
            // at last restore the  mixed-mode
            if (changedScaleFactor < kEraserSize) {//笔
                glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
                [self setBrushColorWithRed:currentRed green:currentGreen blue:currentBlue];
            }
        }
        [lastRecord release];
        lastRecord = nil;
        lastRecord = [[NSMutableData alloc] init];
	}
}
//取消上一步画笔操作（原版，路径取消重绘透明色的方式，不好）
- (void) undoStoke
{
	NSInteger realIndex = 0;
	if (isEndTouch) {//如果这笔已经结束，那么要删除的就是当前Index的前一笔
		realIndex = currentRecordPathCount - 1;
	}
	else {//反之，就是当前一笔
		realIndex = currentRecordPathCount;
	}

	if (realIndex >= 0 && [recordPath count]>=currentRecordPathCount && currentRecordPathCount >= 0) {
        //[undoStorkeImage removeObjectAtIndex:realIndex];
		NSMutableData *data = [recordPath objectAtIndex:realIndex];
		if (data!=nil) {
			CGPoint *point = (CGPoint*)[data bytes];
			NSUInteger count = [data length] / sizeof(CGPoint),i;
			if(count > 0)
			{
				//打开透明画笔
				//You need set the mixed-mode
				glBlendFunc(GL_ONE, GL_ZERO);
				//the erase brush color  is transparent.
				glColor4f(0, 0, 0, 0.0);
				for(i = 0; i < count - 1; ++i, ++point)
				{
					[self drawErase:*point toPoint:*(point + 1)];
				}
				[recordPath removeObjectAtIndex:realIndex];
				currentRecordPathCount--;//删除完以后，当前index要减掉1
				//恢复笔画颜色和混合类型
				// at last restore the  mixed-mode
				glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
				[self setBrushColorWithRed:currentRed green:currentGreen blue:currentBlue];
			}
		}
	}
    if (currentRecordPathCount <= 0) {
        [self.paintViewDelegate noneDrawPath];//没有可以取消的了，要告诉它的代理
    }
}
//删除画笔
- (void) drawErase:(CGPoint)start toPoint:(CGPoint)end
{
    static GLfloat*     eraseBuffer = NULL;
    static NSUInteger   eraseMax = 64;
	
    NSUInteger          vertexCount = 0,
    count,
    i;
	
    [EAGLContext setCurrentContext:context];
    glBindFramebufferOES(GL_FRAMEBUFFER_OES, viewFramebuffer);
	
    // Convert locations from Points to Pixels
    CGFloat scale = 1.0;//self.contentScaleFactor;
    start.x *= scale;
    start.y *= scale;
    end.x *= scale;
    end.y *= scale;
	
    // Allocate vertex array buffer
    if(eraseBuffer == NULL)
        eraseBuffer = malloc(eraseMax * 2 * sizeof(GLfloat));
	
    // Add points to the buffer so there are drawing points every X pixels      
    count = MAX(ceilf(sqrtf((end.x - start.x) * (end.x - start.x) + (end.y - start.y) * (end.y - start.y)) / kBrushPixelStep), 1);
	
    for(i = 0; i < count; ++i) {
        if(vertexCount == eraseMax) {
            eraseMax = 2 * eraseMax;
            eraseBuffer = realloc(eraseBuffer, eraseMax * 2 * sizeof(GLfloat));
        }
		
        eraseBuffer[2 * vertexCount + 0] = start.x + (end.x - start.x) * ((GLfloat)i / (GLfloat)count);
        eraseBuffer[2 * vertexCount + 1] = start.y + (end.y - start.y) * ((GLfloat)i / (GLfloat)count);
        vertexCount += 1;
    }
    //}
    //glEnable(GL_BLEND);   //   打开混合
	//glDisable(GL_DEPTH_TEST);   //   关闭深度测试
	//glBlendFunc(GL_SRC_ALPHA,   GL_ONE);   //   基于源象素alpha通道值的半透明混合函数 
	
	//You need set the mixed-mode
    glBlendFunc(GL_ONE, GL_ZERO);
	//the erase brush color  is transparent.
    glColor4f(0, 0, 0, 0.0);
	
    // Render the vertex array
    glVertexPointer(2, GL_FLOAT, 0, eraseBuffer);
    glDrawArrays(GL_POINTS, 0, vertexCount);
	
    // Display the buffer
    glBindRenderbufferOES(GL_RENDERBUFFER_OES, viewRenderbuffer);
    [context presentRenderbuffer:GL_RENDERBUFFER_OES];
	
	// at last restore the  mixed-mode
//    glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
//	[self setBrushColorWithRed:currentRed green:currentGreen blue:currentBlue];
}
//设置画笔的粗细，一共三级，第一级为较细（当放大画板两倍时缩小后笔触和普通三号字差不多大小；第二级为普通（在不缩放级别的时候写字）；第三级为较粗（笔粗放大两倍）。三级的比例是：0.5:1.0:2.0
- (void) setBruchScaleLevel:(NSInteger) level
{
    self.currentBrushScaleLevel = level;
    switch (level) {
        case 1://较细
            currentScale = kBrushScaleLevel1;
            break;
        case 2://一般
            currentScale = kBrushScale;
            break;
        case 3://较粗
            currentScale = kBrushScaleLevel3;
            break;
        default:
            break;
    }
    glPointSize(self.brushwidth / currentScale);
}
//get image
-(UIImage *) glToUIImage {
	
	NSInteger myDataLength = backingWidth * backingHeight * 4;
	
	// allocate array and read pixels into it.
	GLubyte *buffer = (GLubyte *) malloc(myDataLength);
	glReadPixels(0, 0, backingWidth, backingHeight, GL_RGBA, GL_UNSIGNED_BYTE, buffer);
    
    ///*
	
	// gl renders "upside down" so swap top to bottom into new array.
	// there's gotta be a better way, but this works.
    
	buffer2 = (GLubyte *) malloc(myDataLength);
	
	for(int y = 0; y < backingHeight; y++)
	{
		for(int x = 0; x < backingWidth * 4; x++)
		{
			buffer2[(backingHeight - 1 - y) * backingWidth * 4 + x] = buffer[y * 4 * backingWidth + x];
		}
	}
	free(buffer);
    
	// make data provider with data.
	CGDataProviderRef provider = CGDataProviderCreateWithData(NULL, buffer2, myDataLength, NULL);
	//modified by gyf end
	
	// prep the ingredients
	int bitsPerComponent = 8;
	int bitsPerPixel = 32;
	int bytesPerRow = 4 * backingWidth;
	
	CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceRGB();
	//modified by taojie begin
	//CGBitmapInfo bitmapInfo = kCGBitmapByteOrderDefault;
	CGBitmapInfo bitmapInfo = kCGImageAlphaPremultipliedLast;
	//modified by taojie end
	CGColorRenderingIntent renderingIntent = kCGRenderingIntentDefault;
	
	// make the cgimage
	CGImageRef imageRef = CGImageCreate(backingWidth, backingHeight, bitsPerComponent, bitsPerPixel, 
										bytesPerRow, colorSpaceRef, bitmapInfo, provider, NULL, NO, renderingIntent);
		
	// then make the uiimage from that
	UIImage *myImage = [UIImage imageWithCGImage:imageRef];
	
    CGDataProviderRelease(provider);
    CGColorSpaceRelease(colorSpaceRef);
	CGImageRelease(imageRef);
     //*/
	
	return myImage;
}
- (void)freeBuffer2
{
    if (buffer2) {
        free(buffer2);
    }
}

/*
-(CGImageRef) glToCGImageRef {
	
	NSInteger myDataLength = backingWidth * backingHeight * 4;
	
	// allocate array and read pixels into it.
	GLubyte *buffer = (GLubyte *) malloc(myDataLength);
	glReadPixels(0, 0, backingWidth, backingHeight, GL_RGBA, GL_UNSIGNED_BYTE, buffer);
	
	// gl renders "upside down" so swap top to bottom into new array.
	// there's gotta be a better way, but this works.
	//modified by gyf begin
//	uint32_t* myPtr = (uint32_t*)buffer;
//	for(int i = 0; i < backingWidth * backingHeight; i ++, myPtr ++)
//	{
//		if(myPtr[0] == 0x0)
//		{
//			myPtr[0] = 0xFFFFFF00;
//		}
//		//printf("%x", *myPtr);
//		//printf("\n");
//		
//	}
	GLubyte *buffer2 = (GLubyte *) malloc(myDataLength);
	
	for(int y = 0; y < backingHeight; y++)
	{
		for(int x = 0; x < backingWidth * 4; x++)
		{
			buffer2[(backingHeight - 1 - y) * backingWidth * 4 + x] = buffer[y * 4 * backingWidth + x];
			//printf("%u", buffer2[(backingHeight - 1 - y) * backingWidth * 4 + x]);
		}
	}
	
	// make data provider with data.
	//CGDataProviderRef provider = CGDataProviderCreateWithData(NULL, buffer, myDataLength, NULL);
	CGDataProviderRef provider = CGDataProviderCreateWithData(NULL, buffer2, myDataLength, NULL);
	//modified by gyf end
	
	// prep the ingredients
	int bitsPerComponent = 8;
	int bitsPerPixel = 32;
	int bytesPerRow = 4 * backingWidth;
	
	CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceRGB();
	//modified by taojie begin
	//CGBitmapInfo bitmapInfo = kCGBitmapByteOrderDefault;
	CGBitmapInfo bitmapInfo = kCGImageAlphaPremultipliedLast;
	//modified by taojie end
	CGColorRenderingIntent renderingIntent = kCGRenderingIntentDefault;
	
	// make the cgimage
	CGImageRef imageRef = CGImageCreate(backingWidth, backingHeight, bitsPerComponent, bitsPerPixel, 
										bytesPerRow, colorSpaceRef, bitmapInfo, provider, NULL, NO, renderingIntent);
	//add by gyf begin
	CFRelease(provider);
	CFRelease(colorSpaceRef);
	CFRelease(imageRef);
	//add by gyf end
	
	return imageRef;
}
*/
- (id)paintViewDelegate
{
	return _paintViewDelegate;
}
- (void)setPaintViewDelegate:(id <PaintViewDelegate>)newDelegate
{
	if (newDelegate != _paintViewDelegate && 
		(!newDelegate || [(NSObject *)newDelegate conformsToProtocol:@protocol(PaintViewDelegate)])) {
		_paintViewDelegate = newDelegate;
	}
}
/*
- (void)setScale:(CGFloat)scale {
	currentScale*=scale;
	[self setScaleFactor:currentScale * scaleFactor];
}
*/
@end
