//
//  DownloadRequestDecorator.m
//  Common
//
//  Created by wang hao on 13-9-3.
//  Copyright (c) 2013年 __MyCompanyName__. All rights reserved.
//

#import "DownloadRequestDecorator.h"

#import "UIImage+CustomExtensions.h"
#import "UIColor+CustomExtensions.h"

@interface DownloadRequestDecorator()

/*!
 @function
 @abstract      检测directory是否存在
 
 @param         directory               目录文件夹
 
 @result        NSError                 检测出的错误
 */
-(NSError*)checkFileDirectory:(NSString *)directory;

@end

@implementation DownloadRequestDecorator

@synthesize delegate = _delegate;
/*!
 @function	
 @abstract      初始化网络请求，对父类方法进行覆写，设置请求代理和下载代理
 
 @param         request                 已经完成初始化的请求
 
 @result      
 */
-(id)initWithASIHTTPRequest:(ASIHTTPRequest *)request{
    
    self = [super initWithASIHTTPRequest:request];
    
    if (self) {
        _request.delegate = self;
        _request.downloadProgressDelegate = self;
    }
    
    return self;
}

-(void)setDelegate:(id<ASIHTTPDownloadDelegate>)nDelegate{
    _originalClass = object_getClass(nDelegate);
    _delegate = nDelegate;
}



/*!
 @function	
 @abstract      执行网络请求,对父类方法进行覆写,呼出进度条的显示框
 
 @param     
 
 @result        NSError                 检测出的错误 
 */
-(NSError *)executeRequest{
    
    //检查目标路径是否设置
    if (!_request.downloadDestinationPath) {
        
        //如果没有设置,则返回错误信息
        return [NSError errorWithDomain:@"文件保存目录未设置" code:1 userInfo:nil];
    }
    
    //检查下载缓存目录是否设置
    if (!_request.temporaryFileDownloadPath) {
        
        //如果没有设置缓存目录,打印错误信息
        NSLog(@"%@",[NSError errorWithDomain:@"文件保存目录未设置,默认设置到沙盒临时目录" code:1 userInfo:nil]);
        
        //使用一个随机路径作为临时下载路径
        CFUUIDRef uuidRef = CFUUIDCreate(kCFAllocatorDefault);
        
        CFStringRef fileRef = CFUUIDCreateString(kCFAllocatorDefault, uuidRef);
        
        CFRelease(uuidRef);
        
        NSString  *cachePath = [NSTemporaryDirectory() stringByAppendingPathComponent:(NSString *)fileRef];
        
        CFRelease(fileRef);
        
        //设置文件保存路径
        [_request setTemporaryFileDownloadPath:cachePath];
    }
    
    [self creatAlertViewForProgress];
    
    NSError *error = [super executeRequest];
    
    return error;
}



/*!
 @function	
 @abstract      检测directory是否存在
 
 @param         directory               目录文件夹
 
 @result        NSError                 检测出的错误 
 */
-(NSError*)checkFileDirectory:(NSString *)directory{
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    BOOL flag = NO;
    
    if ([fileManager fileExistsAtPath:directory isDirectory:&flag] && flag) {//directory是文件夹并且存在
        
        return nil;
        
    }
    else{
        
        return [NSError errorWithDomain:@"文件目录不存在" code:1 userInfo:nil];
    }
}



/*!
 @function	
 @abstract      设置下载文件保存路径,如果路径无效,则返回错误信息
 
 @param         path                    下载路径
 
 @result        NSError                 设置文件保存路径的error信息
 */
-(NSError *)setFileSavePath:(NSString *)path{
    
    //检查路径的有效性
    NSError *error = [self checkFileDirectory:[path stringByDeletingLastPathComponent]];
    
    if (!error) {
        
        [_request setDownloadDestinationPath:path];//设置下载路径
    }
    
    return error;
}



/*!
 @function	
 @abstract      设置缓存文件路径,如果路径无效,则返回错误信息
 
 @param         path                    缓存文件路径
 
 @result        NSError                 设置缓存文件路径的error信息
 */
-(NSError *)setFileCachePath:(NSString *)path{
    
    //检查路径的有效性
    NSError *error = [self checkFileDirectory:[path stringByDeletingLastPathComponent]];
    
    if (!error) {
        
        [_request setTemporaryFileDownloadPath:path];
        
    }
 
    return nil;
    
}



/*!
 @function
 @abstract      接收到http响应，处理上传下载文件大小的方法
 
 @param         responseHeaders         返回HTTP头
 @param         request                 请求
 
 @result
 */
- (void)receiveHTTPResponseHeaders:(NSDictionary *)responseHeaders request:(ASIHTTPRequest *)request {
    
//    NSLog(@"%@    %@",responseHeaders,request.url);
    
    _totalSize = [[responseHeaders objectForKey:@"Content-Length"] longLongValue];
}



/*!
 @function	
 @abstract      ASIHTTPRequestDelegate回调，在接受报文头后的处理，展示进度条，若需要后续处理由代理调用
 
 @param         responseHeaders         返回HTTP头 
 @param         request                 请求   
 
 @result      
 */
-(void)request:(ASIHTTPRequest *)request didReceiveResponseHeaders:(NSDictionary *)responseHeaders {
    
    //将提示从请稍后更新为正在下载
    //从响应头中获取下载的报文大小，并设置下载的总大小_totalSize
    //更新最新的进度信息，修改为0/_totalSize
    NSLog(@"%@   %@",request.url,responseHeaders);
    
    [self receiveHTTPResponseHeaders:responseHeaders request:request];
}



/*!
 @function	
 @abstract      ASIHTTPRequestDelegate回调，请求完成后处理
 
 @param         request                 请求 
 
 @result      
 */
-(void)requestFinished:(ASIHTTPRequest *)request {
    //下载完成
    //关闭进图条
    //调用代理downloadRequestFinished方法通知
    
    usleep(100);
    Class currentClass = object_getClass(_delegate);
    if (currentClass == _originalClass) {
        
        if ([_delegate respondsToSelector:@selector(downloadRequestFinished:)]) {
            [_delegate downloadRequestFinished:request];
        }
    }
    
    [self hideLoadingProgressView:request success:YES];
}



/*!
 @function	
 @abstract      ASIHTTPRequestDelegate回调，请求失败后处理
 
 @param         request                 请求  
 
 @result      
 */
-(void)requestFailed:(ASIHTTPRequest *)request {
    //下载失败
    //提示用户下载失败
    //调用代理downloadRequestFaild方法通知
    NSLog(@"%@",request.error);
    
    Class currentClass = object_getClass(_delegate);
    if (currentClass == _originalClass) {
        
        if ([_delegate respondsToSelector:@selector(downloadRequestFailed:)]) {
            
            [_delegate downloadRequestFailed:request];
        }
    }    
    [self hideLoadingProgressView:request success:NO];
}



#pragma mark - ASIProgressDelegate

/*!
 @function	
 @abstract      ASIProgressDelegate回调，在接受数据后的处理，展示进度条 
 
 @param         size                返回包大小
 @param         responseHeaders     返回HTTP头 
 
 @result      
 */
-(void)request:(ASIHTTPRequest *)request didReceiveBytes:(long long)bytes {
    //更新下载进度
    //更新进度条信息
    NSLog(@"bytes---->%lld [request totalBytesRead]--------->%lld",bytes,[request totalBytesRead]);
    [self showRequest:request bytesInTotal:[request totalBytesRead]];
}


/*!
 @function	
 @abstract      创建AlertView类型进度条，重写父类方法，下载的AlertView类型进度条
 
 @param  
 
 @result      
 */
-(void)creatAlertViewForProgress {
    
//    if (!self.progressAlertView.isVisible && _request)
    if (!self.progressAlertView && _request)
    {
        CustomNewAlertView *alertView = [[CustomNewAlertView alloc] initWithTitle:@"下载中" message:@"" delegate:nil cancelButtonTitle:nil otherButtonTitles:nil];
        [alertView setTitleColor:[UIColor whiteColor] font:[UIFont systemFontOfSize:20]];
        [alertView setAlertWidth:260];
        [alertView setAlertHeight:100];
        UIView *bgView = [[UIView alloc] initWithFrame:CGRectMake(10, 30, 240, 30)];
        [alertView addTheview:bgView];
        [bgView setBackgroundColor:[UIColor clearColor]];
        [bgView release];
        //创建进度条
        UIProgressView *progView = [[UIProgressView alloc] initWithFrame:CGRectMake(20.0f, 15.0f, 200.0f, 10.0f)];
        [progView setProgressViewStyle:UIProgressViewStyleBar];
    
        UIImage *img = [UIImage imageNamed:@"loading_02.png" imageBundle:@"Sandglass"];
    
        [progView  setProgressImage:img ];
        [progView  setTrackImage:[UIImage imageNamed:@"loading_01.png" imageBundle:@"Sandglass"]];
        
        [bgView addSubview:progView];
        [progView release];
        
        //创建进度条信息显示
        UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(30.0f, 15.0f, 180.0f, 20.0f)];
        label.backgroundColor = [UIColor clearColor];
        label.textAlignment = UITextAlignmentCenter;
        label.textColor = [UIColor colorWithHex:@"5582A1"];
        label.font = [UIFont systemFontOfSize:10.0f];
        label.text = @"";
        [bgView addSubview:label];
        [label release];
        
        //下载取消按钮
        UIButton *btnCancelLoad = [UIButton buttonWithType:UIButtonTypeCustom];
        btnCancelLoad.frame = CGRectMake(220, 7, 27, 27);
        [btnCancelLoad setImage:[UIImage imageNamed:@"close.png" imageBundle:@"Main"] forState:UIControlStateNormal];
        [btnCancelLoad addTarget:self action:@selector(cancelCurrentRequest) forControlEvents:UIControlEventTouchUpInside];
        [alertView addTheview:btnCancelLoad];
        
        [alertView show];
        
        self.progressAlertView  = alertView;
        self.progressView       = progView;
        self.progressText       = label;
        
        [alertView release];
    }  
}

@end
