//
//  PDFExtend.m
//  PDFExtract
//
//  Created by Sea on 13-5-23.
//  Copyright (c) 2013年 Sea. All rights reserved.
//

#import "PDFExtend.h"

@implementation PDFExtend

//TODO: 将初始位置有偏移的PDF进行坐标的纠正,并重新生成新PDF文件.    该方法返回新PDF文件路径
+ (NSString *)PDFConvertToStandard:(NSString *)originPath password:(NSString *)password{
    
    //初始化原始pdf数据
    CFStringRef originPathRef;
    
    CFURLRef originURLRef;
    
    CGPDFDocumentRef originDocument;
    
    originPathRef = CFStringCreateWithCString(NULL, [originPath UTF8String], kCFStringEncodingUTF8);
    
    originURLRef = CFURLCreateWithFileSystemPath(NULL, originPathRef, kCFURLPOSIXPathStyle, NO);
    
    CFRelease(originPathRef);
    
    originDocument = CGPDFDocumentCreateWithURL(originURLRef);
    
    CFRelease(originURLRef);
    
    bool isEncrypted = CGPDFDocumentIsEncrypted(originDocument);
    
    if (isEncrypted) {
        
        bool isUnlock = CGPDFDocumentUnlockWithPassword(originDocument, [password UTF8String]);
        
        if (!isUnlock) {
            
            NSLog(@"密码错误");
            
            return nil;
        }
    }

    
    CFUUIDRef uuidRef = CFUUIDCreate(kCFAllocatorDefault);
    CFStringRef uuid = CFUUIDCreateString(kCFAllocatorDefault, uuidRef);
    CFRelease(uuidRef);
    
    //创建新PDF文件
    NSString *newFileName = [NSTemporaryDirectory() stringByAppendingPathComponent:[NSString stringWithFormat:@"%@.pdf",(NSString *)uuid]];
    
    CFRelease(uuid);
    
    
    CGContextRef newPDFContext;
    
    CFStringRef newPath;
    
    CFURLRef newURL;
    
    
    newPath = CFStringCreateWithCString (NULL, [newFileName UTF8String], kCFStringEncodingUTF8);
    
    newURL = CFURLCreateWithFileSystemPath (NULL, newPath, kCFURLPOSIXPathStyle, 0);
    
    CFRelease (newPath);
    
    //设置一个标准的尺寸
    CGRect pageRect = CGRectMake(0, 0, 595, 842);
    
    newPDFContext = CGPDFContextCreateWithURL (newURL, &pageRect,NULL);
    
    CFRelease(newURL);
    
    
    //获取原始PDF的每一页数据
    
    size_t pageSize = CGPDFDocumentGetNumberOfPages(originDocument);
    
    for (int i = 1; i <= pageSize; i++) {
        
        CGPDFPageRef originPage = CGPDFDocumentGetPage(originDocument, i);
        
        CGPDFContextBeginPage (newPDFContext, NULL);
        
        //将原始有偏移的PDF坐标纠正,并作为新PDF的坐标系
        CGRect mediaRect = CGPDFPageGetBoxRect(originPage, kCGPDFCropBox);
        
        //按PDF标准尺寸,将PDF原始数据按照标准尺寸进行缩放,防止PDF失真
        CGContextScaleCTM(newPDFContext, pageRect.size.width / mediaRect.size.width,pageRect.size.height / mediaRect.size.height);
        
        CGContextTranslateCTM(newPDFContext, 0, -mediaRect.origin.y);
        //将原始数据按照新坐标系重新生成PDF文件
        CGContextDrawPDFPage(newPDFContext, originPage);
        
        CGPDFContextEndPage (newPDFContext);
    }
    
    CGContextFlush(newPDFContext);
    CGPDFContextClose(newPDFContext);
    
    CGContextRelease (newPDFContext);
    
    return newFileName;
}

@end
