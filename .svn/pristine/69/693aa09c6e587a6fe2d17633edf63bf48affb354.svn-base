//
//  NavScrollController.m
//  MOA
//
//  Created by  on 13-1-31.
//  Copyright (c) 2013年 __MyCompanyName__. All rights reserved.
//

#import "NavScrollController.h"

#import <QuartzCore/QuartzCore.h>


#define kSwipeCloseAnimateTime              0.2
#define kSwipeDisplayAnimateTime            0.3


@implementation NavScrollController

@synthesize viewControllers = _viewControllers;
@synthesize navDelegate;

- (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil
{
    self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil];
    if (self) {
        // Custom initialization
    }
    return self;
}

- (id)init {
    
    self = [super init];
    
    if (self) {
        
        _viewControllers        =   [[NSMutableArray alloc] init];
        
        _viewFrame              =   CGRectZero;
    }
    
    return self;
}

- (void)didReceiveMemoryWarning
{
    // Releases the view if it doesn't have a superview.
    [super didReceiveMemoryWarning];
    
    // Release any cached data, images, etc that aren't in use.
}

- (void)dealloc {
    
    [_viewControllers release];
    
    [super dealloc];
}

#pragma mark - View lifecycle

/*
 // Implement loadView to create a view hierarchy programmatically, without using a nib.
 - (void)loadView
 {
 }
 */

/*
 // Implement viewDidLoad to do additional setup after loading the view, typically from a nib.
 - (void)viewDidLoad
 {
 [super viewDidLoad];
 }
 */

- (void)viewDidUnload
{
    [super viewDidUnload];
    // Release any retained subviews of the main view.
    // e.g. self.myOutlet = nil;
}

- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation
{
    // Return YES for supported orientations
	return YES;
}

#pragma mark - 
#pragma mark 内部调用的函数

+(UIColor *)randomColor{  
    static BOOL seed = NO;  
    if (!seed) {  
        seed = YES;  
        srandom(time(NULL));  
    }  
    CGFloat red = (CGFloat)random()/(CGFloat)RAND_MAX;  
    CGFloat green = (CGFloat)random()/(CGFloat)RAND_MAX;  
    CGFloat blue = (CGFloat)random()/(CGFloat)RAND_MAX;  
    return [UIColor colorWithRed:red green:green blue:blue alpha:1.0f];//alpha为1.0,颜色完全不透明  
}  

//TODO: 加入一个新的viewController具体实现方法
- (BaseScrollView *)initializeWillLoadViewController:(UIViewController *)viewController {
    
    BaseScrollView *lastScrollView = ((UIViewController *)[_viewControllers lastObject]).scrollView;
    
    BaseScrollView *scrollView = nil;
    
    if (!lastScrollView) {
        
        scrollView = [[BaseScrollView alloc] initWithFrame:_viewFrame];
    }
    else
        scrollView = [[BaseScrollView alloc] initWithFrame:CGRectMake(0, 0, lastScrollView.contentSize.width,  lastScrollView.contentSize.height)];
//    scrollView.backgroundColor =[UIColor redColor];

    scrollView.baseDelegate = viewController;
    
    //设置scrollView上所加载的控制器
    [scrollView setChildViewController:viewController];
    
    if (lastScrollView) {
        
        scrollView.lastScrollView = lastScrollView;
        lastScrollView.nextScrollView = scrollView;
        
        //        [scrollView setBackgroundColor:[NavScrollController randomColor]];
        //        [scrollView setTag:222];
        
        [lastScrollView addSubview:scrollView];
    }
    else {
        
        self.view = scrollView;
        
        //        [scrollView setTag:200];
        //        [scrollView setBackgroundColor:[NavScrollController randomColor]];
    }
    
    [scrollView release];
    
    if (_viewControllers.count == 0) {
        
        [UIView animateWithDuration:0.3 animations:^{
            
            CATransition *animation = [CATransition animation];
            animation.duration = 0.3;
            animation.timingFunction = UIViewAnimationCurveEaseInOut;
            animation.fillMode = kCAFillModeForwards;
            animation.type = kCATransitionFade;
            [self.view.layer addAnimation:animation forKey:@"animation"];
            
            [viewController viewWillAppear:YES];
            
            [scrollView addSubview:viewController.view];
            
            [viewController viewDidAppear:YES];
        }];
    }
    else {
        
        [scrollView addSubview:viewController.view];
    }
    
    viewController.scrollView = scrollView;
    viewController.navScrollController = self;
    
    [_viewControllers addObject:viewController];
    [self addChildViewController:viewController];
    
    scrollView.tag = [_viewControllers count];
    
    
    //初始设置视图可左移右移的位置
    if (viewController.leftMoveDistance || viewController.rightMoveDistance) {
        
        [scrollView setOffsetDistance:viewController.leftMoveDistance right:viewController.rightMoveDistance];
    }
    
    return scrollView;
}

- (UIViewController *) closeBaseScrollView:(BaseScrollView *)scrollView animated:(BOOL)animated{
    
    CGRect temp = CGRectMake(1024, 0, 1, 1);
    
    temp = [scrollView.lastScrollView convertRect:temp fromView:[UIApplication sharedApplication].keyWindow.rootViewController.view];
    
    CGRect endRect = scrollView.frame;
    
    endRect.origin.x = temp.origin.x;
    
    if (animated) {
        
        [UIView animateWithDuration:kSwipeCloseAnimateTime animations:^{
            
            scrollView.frame = endRect;
            
        } completion:^(BOOL finished) {
            
            if (finished) {
                
                scrollView.lastScrollView.nextScrollView = nil;//将父视图的指向的子视图地址清空
                
                [_viewControllers removeObject:scrollView.childViewController];
                
                [scrollView removeFromSuperview];
            }
        }];
        
        
    }
    else {
        
        scrollView.lastScrollView.nextScrollView = nil;//将父视图的指向的子视图地址清空
        
        [_viewControllers removeObject:scrollView.childViewController];
        
        [scrollView removeFromSuperview];
    }
    
    return nil;
}


#pragma mark - 
#pragma mark 供外部调用的函数

//TODO: 利用将要展示的viewController初始化视图
- (id)initWithViewFrame:(CGRect)rect withRootViewController:(UIViewController *)viewController {
    
    self = [self init];
    
    _viewFrame  =   rect;
    
    [self initializeWillLoadViewController:viewController];
    
    return self;
}

//TODO: 加入一个新的viewController的入口
- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated {
    
    if (viewController) {
        
        BaseScrollView *scrollView = [self initializeWillLoadViewController:viewController];
        
        if (scrollView.lastScrollView) {
            
            CGFloat leftMoveDistance = scrollView.lastScrollView.childViewController.leftMoveDistance;
            
            CGFloat rightMoveDistance = scrollView.lastScrollView.childViewController.rightMoveDistance;
            
            if (scrollView.lastScrollView.contentOffset.x != leftMoveDistance) {//判断scrollView是否移动到指定位置
                
                [scrollView.lastScrollView setContentOffset:CGPointMake(leftMoveDistance, 0.0) animated:YES];
            }
            
            if (!leftMoveDistance && rightMoveDistance) {//如果设置了左移，则忽略右移
                
                if (scrollView.lastScrollView.contentOffset.x != -rightMoveDistance) {
                    
                    [scrollView.lastScrollView setContentOffset:CGPointMake(-rightMoveDistance, 0.0) animated:YES];
                }
            }
        }
        
        CGRect endRect = scrollView.frame;
        
        CGRect temp = CGRectMake(1024, 0, 1, 1);
        
        temp = [scrollView.lastScrollView convertRect:temp fromView:[UIApplication sharedApplication].keyWindow.rootViewController.view];

        CGRect beginRect = endRect;
        
        beginRect.origin.x = temp.origin.x;
        scrollView.frame = endRect;
        
        scrollView.frame = beginRect;
        
        [UIView animateWithDuration:kSwipeDisplayAnimateTime animations:^{
            
            scrollView.frame = endRect;
        }];
    }
}

- (UIViewController *)popViewControllerAnimated:(BOOL)animated {
    
    if (_viewControllers.count > 1) {
        
        BaseScrollView *scrollView = ((UIViewController *)[_viewControllers lastObject]).scrollView;
        
        return [self closeBaseScrollView:scrollView animated:animated];
    }
    else if (_viewControllers.count == 1) {
        
        [UIView animateWithDuration:0.3 animations:^{
            
            self.view.alpha = 0.0;
            
        }completion:^(BOOL finished) {
            if (finished)
            {
                BaseScrollView *scrollView = ((UIViewController *)[_viewControllers lastObject]).scrollView;
                [scrollView setContentOffset:CGPointMake(0, 0) animated:YES];
                
                if (navDelegate && [navDelegate respondsToSelector:@selector(closeRootControllerAction)])
                {
                    [navDelegate closeRootControllerAction];
                }
            }
        }];
        
        return nil;
    }
    
    return nil;
}

- (void)changeRootViewController:(UIViewController *)viewController animated:(BOOL)animated {

    int i = _viewControllers.count;
    
    while (i > 1) {
        
        UIViewController *oldViewController = (UIViewController *)[_viewControllers lastObject];
        
        BaseScrollView *scrollView = oldViewController.scrollView;
        
        CGRect temp = CGRectMake(1024, 0, 1, 1);
        
        temp = [scrollView.lastScrollView convertRect:temp fromView:[UIApplication sharedApplication].keyWindow.rootViewController.view];
        
        CGRect endRect = scrollView.frame;
        
        endRect.origin.x = temp.origin.x;
        
        [UIView animateWithDuration:kSwipeCloseAnimateTime animations:^{
            
            scrollView.frame = endRect;
            
            [scrollView.lastScrollView setContentOffset:CGPointMake(0.0, 0.0) animated:YES];//将其父视图归位
            
        } completion:^(BOOL finished) {
            
            if (finished) {
                
                scrollView.lastScrollView.nextScrollView = nil;//将父视图的指向的子视图地址清空
                
                [scrollView removeFromSuperview];
            }
        }];
        
        [_viewControllers removeObject:oldViewController];
        
        i = _viewControllers.count;
    }
    
    if (i == 1) {
        
        UIViewController *oldViewController = (UIViewController *)[_viewControllers lastObject];
        
        if (oldViewController == viewController) {
            
            if (self.view.alpha == 0.0) {
                
                [UIView animateWithDuration:0.3 animations:^{
                    
                    CATransition *animation = [CATransition animation];
                    animation.duration = 0.3;
                    animation.timingFunction = UIViewAnimationCurveEaseInOut;
                    animation.fillMode = kCAFillModeForwards;
                    animation.type = kCATransitionFade;
                    [self.view.layer addAnimation:animation forKey:@"animation"];
                    
                    self.view.alpha = 1.0;
                    
                }];
            }
            
            return;//如果要切换的视图便是当前视图,则不做处理
        }
        
        BaseScrollView *scrollView = oldViewController.scrollView;
        scrollView.lastScrollView.nextScrollView = nil;
        
        scrollView.baseDelegate = viewController;
        
        //设置scrollView上所加载的控制器
        [scrollView setChildViewController:viewController];
        viewController.scrollView = scrollView;
        viewController.navScrollController = self;
        
        [scrollView setContentOffset:CGPointMake(0.0, 0.0) animated:YES];
        
        [UIView animateWithDuration:0.3 animations:^{
            
            CATransition *animation = [CATransition animation];
            animation.duration = 0.3;
            animation.timingFunction = UIViewAnimationCurveEaseInOut;
            animation.fillMode = kCAFillModeForwards;
            animation.type = kCATransitionFade;
            [self.view.layer addAnimation:animation forKey:@"animation"];
            
            if (self.view.alpha == 0.0) {
                
                self.view.alpha = 1.0;
            }
            
            [viewController viewWillAppear:YES];
            [oldViewController viewWillDisappear:YES];
            
            [oldViewController.view removeFromSuperview];
            [scrollView addSubview:viewController.view];
            
            [oldViewController viewDidDisappear:YES];
            [oldViewController viewDidAppear:YES];
            
        }];
        
        [self addChildViewController:viewController];
        [_viewControllers replaceObjectAtIndex:0 withObject:viewController];
    }
}

- (NSArray *)popToViewController:(UIViewController *)viewController animated:(BOOL)animated {
    
    return nil;
}

//TODO: 返回到第一级页面
- (void)popToRootViewControllerAnimated:(BOOL)animated {
    
    //    NSRange range = NSMakeRange(1, (_bottomScrollViewList.count - 1));
    //    
    //    [_bottomScrollViewList removeObjectsInRange:range];
    //    
    //    [_viewControllers removeAllObjects];
    
    UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@"提示" message:@"返回到低级目录未实现" delegate:nil cancelButtonTitle:@"好" otherButtonTitles:nil];
    
    [alertView show];
    
    [alertView release];
    
}

@end


/*
 ********************************************************************************************
 ********************************************************************************************
 ********************************************************************************************
 ********************************************************************************************
 ********************************************************************************************
 */

//滑动关闭距离
#define kClosePromptDistance                          120

@implementation BaseScrollView

@synthesize baseDelegate = _baseDelegate;

@synthesize childViewController = _childViewController;
@synthesize lastScrollView;
@synthesize nextScrollView;
@synthesize validZone;

- (CGRect)validZone {
    
    return _childViewController.view.frame;
}

- (void)setNextScrollView:(BaseScrollView *)newNextScrollView {
    
    nextScrollView = newNextScrollView;
    
    CGRect rect = nextScrollView.childViewController.view.frame;
    
    rect.origin.x = rect.origin.x + _leftDistance - _rightDistance;
    
    nextScrollView.childViewController.view.frame = rect;
    
}


- (void)dealloc {
    
    self.childViewController = nil;
    
    self.lastScrollView = nil;
    self.nextScrollView = nil;
    
    self.baseDelegate   = nil;
    
    [super dealloc];
}

- (id)initWithFrame:(CGRect)frame {
    
    self = [super initWithFrame:frame];
    
    [self setContentSize:CGSizeMake(frame.size.width + 1, frame.size.height)];
    
    [self setDelegate:self];
    [self setClipsToBounds:NO];
    
    [self setShowsVerticalScrollIndicator:NO];
    [self setShowsHorizontalScrollIndicator:NO];
    [self setScrollsToTop:NO];
    [self setBounces:YES];
    [self setDecelerationRate:UIScrollViewDecelerationRateNormal];
    
    [self setCanCancelContentTouches:YES]; 
    
    [self setDelaysContentTouches:NO];
    
    return self;
}

//TODO:视图碰撞检测
- (BOOL)hitTestNextScrollView:(BaseScrollView *)scrollView point:(CGPoint)point{
    
    if (scrollView.nextScrollView) {
        
        CGPoint newPoint = [scrollView convertPoint:point toView:scrollView.nextScrollView];//将当前视图位置坐标转换为下级scrollView位置坐标
        
        return [self hitTestNextScrollView:scrollView.nextScrollView point:newPoint];
    }
    else {
        
        if (CGRectContainsPoint(scrollView.validZone, point)) {//判断当前触摸点是否在下级scrollView有效位置中
            
            return YES;//[super pointInside:point withEvent:event];
        }
        else {
            
            return NO;
        }
    }
}

//TODO: 判断触摸点是否需要响应
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event {
    
    if (CGRectContainsPoint(self.validZone, point)) {
        
        return [super pointInside:point withEvent:event];
    }
    else {//如果触摸点不在有效区域内
        
        CGPoint newPoint = [self convertPoint:point toView:self.nextScrollView];
        
        return [self hitTestNextScrollView:self.nextScrollView point:newPoint];
    }
}


- (BOOL)touchesShouldBegin:(NSSet *)touches withEvent:(UIEvent *)event inContentView:(UIView *)view {
    
    if (self.lastScrollView) {
        
        self.lastScrollView.scrollEnabled = NO;
        
        double delayInSeconds = 0.5;
        dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));
        dispatch_after(popTime, dispatch_get_main_queue(), ^(void){
            
            self.lastScrollView.scrollEnabled = YES;
        });
        
        return YES;
    }
    
   return [super touchesShouldBegin:touches withEvent:event inContentView:view];
}

//TODO: 设置加载的控制器可左移右移的距离; 默认:不可左移右移到某个位置
- (void)setOffsetDistance:(CGFloat)leftDistance right:(CGFloat)rightDistance {
    
    _leftDistance = leftDistance;
    _rightDistance = rightDistance;
    
    //更改scrollView的contentSize 以左右移
    [self setContentSize:CGSizeMake(self.frame.size.width + leftDistance + rightDistance, self.frame.size.height)];
    
    //将相对于屏幕位置的坐标更改为相对于本身的坐标
    CGRect rect = _childViewController.view.frame;
    
    rect.origin.x = rect.origin.x - self.contentOffset.x;//先还原原先坐标
    
    rect = [self convertRect:rect fromView:[UIApplication sharedApplication].keyWindow.rootViewController.view];
    
    //lixiangai
    if ([[UIDevice currentDevice].systemVersion doubleValue]>=7.0)
    {
        if (rect.origin.y < 0)
        {
            rect.origin.y = 0;
        }
    }
    
    [UIView animateWithDuration:kSwipeDisplayAnimateTime animations:^{
        
        _childViewController.view.frame = rect;
    }];
}

//TODO: 设置自身上加载的viewController,取得其引用
- (void)setChildViewController:(UIViewController *)viewController {
    
    _childViewController = viewController;//viewController与所在的scrollView是同步存在的,因此用同一个引用
}

#pragma mark -
#pragma mark UIScrollViewDelegate methods

- (void)scrollViewDidScroll:(UIScrollView *)scrollView {
    
    NSLog(@"%@",NSStringFromCGPoint(scrollView.contentOffset));
    
    if (self.isDragging) {
        
        if (scrollView.contentOffset.x < -kClosePromptDistance) {
            
            if (_baseDelegate && [_baseDelegate respondsToSelector:@selector(scrollViewReachCloseZone:)]) {
                
                [_baseDelegate scrollViewReachCloseZone:YES];
            }
        }
        else {
            
            if (_baseDelegate && [_baseDelegate respondsToSelector:@selector(scrollViewReachCloseZone:)]) {
                
                [_baseDelegate scrollViewReachCloseZone:NO];
            }
        }
    }
    
    if (_childViewController.leftMoveEndDistance ) {//控制左移的截止距离  右移截止距离暂时没有控制
        
        if (scrollView.contentOffset.x >0 && scrollView.contentOffset.x > _childViewController.leftMoveEndDistance) {
            [scrollView setContentOffset:CGPointMake(_childViewController.leftMoveEndDistance, 0) animated:NO];
        }
    }
}

- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView{
    
    _previousPoint = scrollView.contentOffset;
}

- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate {
    
    if (!decelerate) {
        
        [scrollView setContentOffset:scrollView.contentOffset animated:NO];
        
        if (self.nextScrollView) {
            
            //如果该scrollView有子级scrollView,则不会关闭
            
            if (scrollView.contentOffset.x - _previousPoint.x > 0) {
                
                [scrollView setContentOffset:CGPointMake(_leftDistance, 0) animated:YES];
            }
            else if (_previousPoint.x - scrollView.contentOffset.x > 0){
                [scrollView setContentOffset:CGPointMake(0, 0) animated:YES];
            }
            
        }
        else {
            
            switch (_childViewController.type) {
                    
                case DefaultType: {
                        
                        //当detailView滑出超过一段距离后，将其自动关闭
                        if (self.lastScrollView && scrollView.contentOffset.x < -kClosePromptDistance) {
                            
                            if (_baseDelegate && [_baseDelegate respondsToSelector:@selector(scrollViewDidMoveToClose:)]) {
                                
                                //每次关闭都需要将其父视图复位
                                [_baseDelegate scrollViewDidMoveToClose:self];
                                
                                [self.lastScrollView setContentOffset:CGPointMake(0.0, 0.0) animated:YES];
                            }
                            else {
                                
                                [scrollView setContentOffset:scrollView.contentOffset animated:NO];
                                [scrollView setContentOffset:CGPointMake(0.0, 0.0) animated:YES];
                            }  
                        }
                        else {//否则detailView复位
                            
                            [scrollView setContentOffset:scrollView.contentOffset animated:NO];
                            [scrollView setContentOffset:CGPointMake(0.0, 0.0) animated:YES];
                        }
                    
                }
                    
                    break;
                    
                default:
                    break;
            }
        }
    }
}
- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView {
    
    [scrollView setContentOffset:scrollView.contentOffset animated:NO];
    
    if (self.nextScrollView) {
        
        if (scrollView.contentOffset.x - _previousPoint.x > 0) {
            
            [scrollView setContentOffset:CGPointMake(_leftDistance, 0) animated:YES];
        }
        else if (_previousPoint.x - scrollView.contentOffset.x > 0){
            [scrollView setContentOffset:CGPointMake(0, 0) animated:YES];
        }
    }
    else {
        
        switch (_childViewController.type) {
                
            case DefaultType: {
                
                //当detailView滑出超过一段距离后，将其自动关闭
                if (self.lastScrollView && scrollView.contentOffset.x < -kClosePromptDistance) {
                    
                    if (_baseDelegate && [_baseDelegate respondsToSelector:@selector(scrollViewDidMoveToClose:)]) {
                        
                        //每次关闭都需要将其父视图复位
                        [_baseDelegate scrollViewDidMoveToClose:self];
                        
                        [self.lastScrollView setContentOffset:CGPointMake(0.0, 0.0) animated:YES];
                    }
                    else {
                        
                        [scrollView setContentOffset:scrollView.contentOffset animated:NO];
                        [scrollView setContentOffset:CGPointMake(0.0, 0.0) animated:YES];
                    }
                }
                else {//否则detailView复位
                    
                    if ([_childViewController.navScrollController.viewControllers count] == 1)
                    {
                        if (- scrollView.contentOffset.x > 80)
                        {
                            [scrollView setContentOffset:CGPointMake(-160, 0.0) animated:YES];
                        }
                        else
                        {
                            [scrollView setContentOffset:scrollView.contentOffset animated:NO];
                            [scrollView setContentOffset:CGPointMake(0.0, 0.0) animated:YES];
                        }
                    }
                }
            }
                break;
                
            default:
                break;
        }  
    } 
}

- (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView {
    
}

@end


////////////////////////////////////////////////////////////////////////////////

#import <objc/runtime.h>

static char navScrollKey;
static char scrollViewKey;
static char baseDelegateKey;
static char leftMoveDistanceKey;
static char rightMoveDistanceKey;
static char leftMoveEndDistanceKey;
static char rightMoveEndDistanceKey;
static char typeKey;

static char isSwipingKey;

@implementation UIViewController (NavScrollController)

- (void)setNavScrollController:(NavScrollController *)newController {
    
    objc_setAssociatedObject(self, &navScrollKey, newController, OBJC_ASSOCIATION_ASSIGN);
}


- (NavScrollController *)navScrollController {
    
    return objc_getAssociatedObject(self, &navScrollKey);
}


- (void)setScrollView:(BaseScrollView *)newScrollView {
    
    objc_setAssociatedObject(self, &scrollViewKey, newScrollView, OBJC_ASSOCIATION_ASSIGN);
}

- (BaseScrollView *)scrollView {
    
    return objc_getAssociatedObject(self, &scrollViewKey);
}

- (void)setBaseDelegate:(id<BaseScrollViewDelegate>)newBaseDelegate {
    
     objc_setAssociatedObject(self, &baseDelegateKey, newBaseDelegate, OBJC_ASSOCIATION_ASSIGN);
}

- (id<BaseScrollViewDelegate>)baseDelegate {
    
    return objc_getAssociatedObject(self, &baseDelegateKey);
}

- (void)setLeftMoveDistance:(CGFloat)newLeftMoveDistance {
    
    objc_setAssociatedObject(self, &leftMoveDistanceKey, [NSNumber numberWithFloat:newLeftMoveDistance], OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    
    //修改左移位置
    [self.scrollView setOffsetDistance:newLeftMoveDistance right:self.rightMoveDistance];
}

- (float)leftMoveDistance {
    
    return [objc_getAssociatedObject(self, &leftMoveDistanceKey) floatValue];
}

- (void)setRightMoveDistance:(CGFloat)newRightMoveDistance {
    
    objc_setAssociatedObject(self, &rightMoveDistanceKey, [NSNumber numberWithFloat:newRightMoveDistance], OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    //修改右移位置
    [self.scrollView setOffsetDistance:self.leftMoveDistance right:newRightMoveDistance];
}

- (float)rightMoveDistance {
    
    return [objc_getAssociatedObject(self, &rightMoveDistanceKey) floatValue];
}

- (void)setLeftMoveEndDistance:(CGFloat)nLeftMoveEndDistance {
    
    objc_setAssociatedObject(self, &leftMoveEndDistanceKey, [NSNumber numberWithFloat:nLeftMoveEndDistance], OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

- (float)leftMoveEndDistance {
    
    return [objc_getAssociatedObject(self, &leftMoveEndDistanceKey) floatValue];
}

- (void)setRightMoveEndDistance:(CGFloat)nRightMoveEndDistance {
 
    objc_setAssociatedObject(self, &rightMoveEndDistanceKey, [NSNumber numberWithFloat:nRightMoveEndDistance], OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

- (float)rightMoveEndDistance {
    
    return [objc_getAssociatedObject(self, &rightMoveEndDistanceKey) floatValue];
}

- (void)setType:(ControllerType)newType {
    
    objc_setAssociatedObject(self, &typeKey, [NSNumber numberWithInteger:newType], OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

- (ControllerType)type {
    
    return [objc_getAssociatedObject(self, &typeKey) integerValue];
}

- (BOOL)isNextInitialize {
    
    if (self.scrollView.nextScrollView) {
        
        return YES;
    }
    else
        return NO;
}

- (void)setIsSwiping:(BOOL)nIsSwiping {
    
    objc_setAssociatedObject(self, &isSwipingKey, [NSNumber numberWithBool:nIsSwiping], OBJC_ASSOCIATION_ASSIGN);
    
}

- (BOOL)isSwiping {
    
    return [objc_getAssociatedObject(self, &isSwipingKey) boolValue];
    
}

- (void)presentViewController:(CGRect)newFrame {
    
    [UIView animateWithDuration:kSwipeDisplayAnimateTime animations:^{
        
        self.view.frame = newFrame;
        
    } completion:^(BOOL finished) {
        
        if (finished) {
            
//            self.scrollView.lastScrollView.userInteractionEnabled = YES;
            
            self.isSwiping = NO;
        }
    }];
}

- (void)presentViewControllerAfterSwipeRight {
    
    if (!self.isSwiping)
    {
        self.isSwiping = YES;
        
        self.scrollView.lastScrollView.userInteractionEnabled = YES;
        
        __block CGRect originalFrame = self.view.frame;
        
        CGRect temp = CGRectMake(1024, 0, 1, 1);
        
        temp = [self.scrollView convertRect:temp fromView:[UIApplication sharedApplication].keyWindow.rootViewController.view];
        
        CGRect endRect = self.view.frame;
        
        endRect.origin.x = temp.origin.x;
        
        [UIView animateWithDuration:kSwipeCloseAnimateTime animations:^{
            
            self.view.frame = endRect;
            
        } completion:^(BOOL finished) {
            
            if (finished) {
                
                [self presentViewController:originalFrame];
            }
        }];
    }
    
}

@end
