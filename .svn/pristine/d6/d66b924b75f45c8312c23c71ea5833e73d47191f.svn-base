//
//  CommonUtility.m
//  GLPaint
//
//  Created by 陶杰 on 11-7-31.
//  Copyright 2011 __MyCompanyName__. All rights reserved.
//

#import "PaintUtility.h"

#import "PDFDocument.h"
#import "PDFToolViewController.h"

@implementation PaintUtility
//根据两个点计算第-1个虚拟点
+ (CGPoint)getNagetivePointByCurrentPoints:(CGPoint)currentPoint previousPoint:(CGPoint)previousPoint {
	CGFloat xn1 = 2 * previousPoint.x - currentPoint.x;
	CGFloat yn1 = 2 * previousPoint.y - currentPoint.y;
	return CGPointMake(xn1,yn1);
}
//根据两个点计算第2个虚拟点
+ (CGPoint)getPostivePointByCurrentPoints:(CGPoint)currentPoint previousPoint:(CGPoint)previousPoint {
	CGFloat xp1 = 2 * currentPoint.x - previousPoint.x;
	CGFloat yp1 = 2 * currentPoint.y - previousPoint.y;
	return CGPointMake(xp1,yp1);
}

+ (void)computeBezierControlPointBy4PointsP0:(CGPoint)p0 p1:(CGPoint)p1 p2:(CGPoint)p2 p3:(CGPoint)p3 c1:(CGPoint *)c1 c2:(CGPoint *)c2 {
	CGFloat x0,y0,x1,y1,x2,y2,x3,y3;
	x0 = p0.x;
	y0 = p0.y;
	x1 = p1.x;
	y1 = p1.y;
	x2 = p2.x;
	y2 = p2.y;
	x3 = p3.x;
	y3 = p3.y;
	
	//calculate two control points
	CGFloat ctrl1_x = x1 + kSmoothValueX * (x2 - x0);
	CGFloat ctrl1_y = y1 + kSmoothValueY * (y2 - y0);     
	CGFloat ctrl2_x = x2 - kSmoothValueX * (x3 - x1);    
	CGFloat ctrl2_y = y2 - kSmoothValueY * (y3 - y1);
	
	*c1 = CGPointMake(ctrl1_x, ctrl1_y);
	*c2 = CGPointMake(ctrl2_x, ctrl2_y);
}

//将PNG文件写入Document目录下，以FileName为文件名
+ (void)writePNGFileToFileName:(NSString *)fileName image:(UIImage *)image
{
    NSString  *pngPath = [NSHomeDirectory() stringByAppendingPathComponent:[NSString stringWithFormat:@"Documents/%@",fileName]];
    [UIImagePNGRepresentation(image) writeToFile:pngPath atomically:YES];
}

void ProviderReleaseData (void *info, const void *data, size_t size)
{
	free((void*)data);
}

+ (UIImage*) imageBlackToTransparent:(UIImage*) image
{    
    // 分配内存
    const int imageWidth = image.size.width;
    const int imageHeight = image.size.height;    
    size_t bytesPerRow = imageWidth * 4;
    uint32_t* rgbImageBuf = (uint32_t*)malloc(bytesPerRow * imageHeight);
    
    // 创建context
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = CGBitmapContextCreate(rgbImageBuf, imageWidth, imageHeight, 8, bytesPerRow, colorSpace, 
                                                 kCGBitmapByteOrder32Little | kCGImageAlphaNoneSkipLast);
    //CGContextDrawImage(context, CGRectMake(0, 0, imageWidth, imageHeight), image.CGImage);
    CGContextDrawImage(context, CGRectMake(0, 0, imageWidth, imageHeight), [image CGImage]);
	
    // 遍历像素
    int pixelNum = imageWidth * imageHeight;
    uint32_t* pCurPtr = rgbImageBuf; 
    for (int i = 0; i < pixelNum; i++, pCurPtr++)
    {
        if ((*pCurPtr & 0xFFFFFF00) == 0)    // 将黑色变成透明
        {
            uint8_t* ptr = (uint8_t*)pCurPtr;
            ptr[0] = 0;
        }
		
        // 改成下面的代码，会将图片转成灰度
        /*
		 uint8_t* ptr = (uint8_t*)pCurPtr;
		 // gray = red * 0.11 + green * 0.59 + blue * 0.30
		 uint8_t gray = ptr[3] * 0.11 + ptr[2] * 0.59 + ptr[1] * 0.30;    
		 ptr[3] = gray;
		 ptr[2] = gray;
		 ptr[1] = gray;
		 */
    }
    
    // 将内存转成image
    CGDataProviderRef dataProvider = CGDataProviderCreateWithData(NULL, rgbImageBuf, bytesPerRow * imageHeight, ProviderReleaseData);
    CGImageRef imageRef = CGImageCreate(imageWidth, imageHeight, 8, 32, bytesPerRow, colorSpace, 
										kCGImageAlphaLast | kCGBitmapByteOrder32Little, dataProvider, 
                                        NULL, true, kCGRenderingIntentDefault);
    CGDataProviderRelease(dataProvider);
    
    UIImage* resultUIImage = [UIImage imageWithCGImage:imageRef];
    
    // 释放
    CGImageRelease(imageRef);
    CGContextRelease(context);
    CGColorSpaceRelease(colorSpace);
    // free(rgbImageBuf) 创建dataProvider时已提供释放函数，这里不用free
    
    return resultUIImage;
}

+ (NSString *)createUUID
{
	// Create universally unique identifier (object)
	CFUUIDRef uuidObject = CFUUIDCreate(kCFAllocatorDefault);
	
	// Get the string representation of CFUUID object.
	NSString *uuidStr = (NSString *)CFUUIDCreateString(kCFAllocatorDefault, uuidObject);
	
	CFRelease(uuidObject);
	
	return [uuidStr autorelease];
}

//图片合并，将两个图片合并成一个图片
+ (UIImage *)addTwoImageToOne:(UIImage *) oneImg twoImage:(UIImage *) twoImg
{
    UIGraphicsBeginImageContext(oneImg.size);
    [oneImg drawInRect:CGRectMake(0, 0, oneImg.size.width, oneImg.size.height)];
    [twoImg drawInRect:CGRectMake(0, 0, twoImg.size.width, twoImg.size.height)];
    UIImage *resultImg = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return resultImg;
}

//将imageNamed函数转换为ImageWithContentFile函数
+(UIImage *)imageNamedFromContentFile:(NSString *)fileName
{
    return [UIImage imageWithContentsOfFile:[NSString stringWithFormat:@"%@/%@", [[NSBundle mainBundle] bundlePath], fileName]];
}

@end